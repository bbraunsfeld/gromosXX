%!PS-Adobe-3.0
%%Title: nonbonded_outerloop.cc
%%For: Patrick Bleiziffer
%%Creator: a2ps version 4.14
%%CreationDate: Thu Dec  6 14:56:07 2018
%%BoundingBox: 24 24 588 768
%%DocumentData: Clean7Bit
%%Orientation: Landscape
%%Pages: 20
%%PageOrder: Ascend
%%DocumentMedia: Letter 612 792 0 () ()
%%DocumentNeededResources: font Courier
%%+ font Courier-Bold
%%+ font Courier-BoldOblique
%%+ font Courier-Oblique
%%+ font Helvetica
%%+ font Helvetica-Bold
%%+ font Symbol
%%+ font Times-Bold
%%+ font Times-Roman
%%DocumentProcessColors: Black 
%%DocumentSuppliedResources: procset a2ps-a2ps-hdr
%%+ procset a2ps-black+white-Prolog
%%+ encoding ISO-8859-1Encoding
%%EndComments
/a2psdict 200 dict def
a2psdict begin
%%BeginProlog
%%Copyright: (c) 1988, 89, 90, 91, 92, 93 Miguel Santana
%%Copyright: (c) 1995, 96, 97, 98 Akim Demaille, Miguel Santana
% Check PostScript language level.
/languagelevel where {
  pop /gs_languagelevel languagelevel def
} {
  /gs_languagelevel 1 def
} ifelse

% EPSF import as in the Red Book
/BeginInclude {
  /b4_Inc_state save def    		% Save state for cleanup
  /dict_count countdictstack def	% Count objects on dict stack
  /op_count count 1 sub def		% Count objects on operand stack 
  userdict begin
    0 setgray 0 setlinecap
    1 setlinewidth 0 setlinejoin
    10 setmiterlimit [ ] 0 setdash newpath
    gs_languagelevel 1 ne {
      false setstrokeadjust false setoverprint 
    } if
} bind def

/EndInclude {
  count op_count sub { pos } repeat	% Clean up stacks
  countdictstack dict_count sub { end } repeat
  b4_Inc_state restore
} bind def

/BeginEPSF {
  BeginInclude
  /showpage { } def
} bind def

/EndEPSF {
  EndInclude
} bind def

% Page prefeed
/page_prefeed {         % bool -> -
  statusdict /prefeed known {
    statusdict exch /prefeed exch put
  } {
    pop
  } ifelse
} bind def

/deffont {
  findfont exch scalefont def
} bind def

/reencode_font {
  findfont reencode 2 copy definefont pop def
} bind def

% Function c-show (str => -)
% centers text only according to x axis.
/c-show { 
  dup stringwidth pop
  2 div neg 0 rmoveto
  show
} bind def

% Function l-show (str => -)
% prints texts so that it ends at currentpoint
/l-show {
  dup stringwidth pop neg 
  0 
  rmoveto show
} bind def

% center-fit show (str w => -)
% show centered, and scale currentfont so that the width is less than w
/cfshow {
  exch dup stringwidth pop
  % If the title is too big, try to make it smaller
  3 2 roll 2 copy
  gt
  { % if, i.e. too big
    exch div
    currentfont exch scalefont setfont
  } { % ifelse
    pop pop 
  }
  ifelse
  c-show			% center title
} bind def

% Return the y size of the current font
% - => fontsize
/currentfontsize {
  currentfont /FontType get 0 eq {
    currentfont /FontMatrix get 3 get
  }{
    currentfont /FontMatrix get 3 get 1000 mul
  } ifelse
} bind def

% reencode the font
% <encoding-vector> <fontdict> -> <newfontdict>
/reencode { %def
  dup length 5 add dict begin
    { %forall
      % <vector> <key> <val>
      1 index /FID ne 
      { def }{ pop pop } ifelse
    } forall
    /Encoding exch def % -

    % Use the font's bounding box to determine the ascent, descent,
    % and overall height; don't forget that these values have to be
    % transformed using the font's matrix.
    % We use `load' because sometimes BBox is executable, sometimes not.
    % Since we need 4 numbers an not an array avoid BBox from being executed
    /FontBBox load aload pop
    FontMatrix transform /Ascent exch def pop
    FontMatrix transform /Descent exch def pop
    /FontHeight Ascent Descent sub def

    % Get the underline position and thickness if they're defined.
    % Use 1 if they are not defined.
    currentdict /FontInfo 2 copy known
    { get
      /UnderlinePosition 2 copy % <FontInfo> /UP <FontInfo> /UP
      2 copy known
      { get }{ pop pop 1 } ifelse
      0 exch FontMatrix transform exch pop
      def % <FontInfo>

      /UnderlineThickness 2 copy % <FontInfo> /UT <FontInfo> /UT
      2 copy known
      { get }{ pop pop 1 } ifelse
      0 exch FontMatrix transform exch pop
      def % <FontInfo>
      pop % -
    }{ pop pop
    } ifelse

    currentdict
  end 
} bind def

% composite fonts for ASCII-EUC mixed string
% Version 1.2 1/31/1990
% Orignal Ken'ichi HANDA (handa@etl.go.jp)
% Modified Norio Katayama (katayama@rd.nacsis.ac.jp),1998
% Extend & Fix Koji Nakamaru (maru@on.cs.keio.ac.jp), 1999
% Anyone can freely copy, modify, distribute this program.

/copyfont {	% font-dic extra-entry-count  copyfont  font-dic
	1 index maxlength add dict begin
	{	1 index /FID ne 2 index /UniqueID ne and
		{def} {pop pop} ifelse
	} forall
	currentdict
	end
} bind def

/compositefont { % ASCIIFontName EUCFontName RomanScale RomanOffset Rot(T/F) compositefont font
    /RomanRotation exch def
    /RomanOffset exch def
    /RomanScale exch def
    userdict /fixeucfont_dict known not {
	userdict begin
	    /fixeucfont_dict 2 dict begin
		/UpperByteEncoding [
		    16#00 1 16#20 { pop 0 } for
		    16#21 1 16#28 { 16#20 sub } for
		    16#29 1 16#2F { pop 0 } for
		    16#30 1 16#74 { 16#27 sub } for
		    16#75 1 16#FF { pop 0 } for
		] def
	        /LowerByteEncoding [
		    16#00 1 16#A0 { pop /.notdef } for
		    16#A1 1 16#FE { 16#80 sub 16 2 string cvrs
				    (cXX) dup 1 4 -1 roll
				    putinterval cvn } for
		    /.notdef
		] def
		currentdict
	    end def
	end
    } if
    findfont dup /FontType get 0 eq {
	14 dict begin
	    %
	    % 7+8 bit EUC font
	    %
	    12 dict begin
		/EUCFont exch def
		/FontInfo (7+8 bit EUC font) readonly def
		/PaintType 0 def
		/FontType 0 def
		/FontMatrix matrix def
		% /FontName
		/Encoding fixeucfont_dict /UpperByteEncoding get def
		/FMapType 2 def
		EUCFont /WMode known
		{ EUCFont /WMode get /WMode exch def }
		{ /WMode 0 def } ifelse
		/FDepVector [
		    EUCFont /FDepVector get 0 get
		    [ 16#21 1 16#28 {} for 16#30 1 16#74 {} for ]
		    {
			13 dict begin
			    /EUCFont EUCFont def
			    /UpperByte exch 16#80 add def	
			    % /FontName
			    /FontInfo (EUC lower byte font) readonly def
			    /PaintType 0 def
			    /FontType 3 def
			    /FontMatrix matrix def
			    /FontBBox {0 0 0 0} def
			    /Encoding
				fixeucfont_dict /LowerByteEncoding get def
			    % /UniqueID
			    % /WMode
			    /BuildChar {
				gsave
				exch dup /EUCFont get setfont
				/UpperByte get
				2 string
				dup 0 4 -1 roll put
				dup 1 4 -1 roll put
				dup stringwidth setcharwidth
				0 0 moveto show
				grestore
			    } bind def
			    currentdict
			end
			/lowerbytefont exch definefont
		    } forall
		] def
		currentdict
	    end
	    /eucfont exch definefont
	    exch
	    findfont 1 copyfont dup begin
		RomanRotation {
			/FontMatrix FontMatrix
			[ 0 RomanScale neg RomanScale 0 RomanOffset neg 0 ]
			matrix concatmatrix def
		}{
			/FontMatrix FontMatrix
			[ RomanScale 0 0 RomanScale 0 RomanOffset ] matrix concatmatrix
			def
			/CDevProc
			    {pop pop pop pop 0 exch -1000 exch 2 div 880} def
		} ifelse
	    end
	    /asciifont exch definefont
	    exch
	    /FDepVector [ 4 2 roll ] def
	    /FontType 0 def
	    /WMode 0 def
	    /FMapType 4 def
	    /FontMatrix matrix def
	    /Encoding [0 1] def
	    /FontBBox {0 0 0 0} def
%	    /FontHeight 1.0 def % XXXX
	    /FontHeight RomanScale 1.0 ge { RomanScale }{ 1.0 } ifelse def
	    /Descent -0.3 def   % XXXX
	    currentdict
	end
	/tmpfont exch definefont
	pop
	/tmpfont findfont
    }{
	pop findfont 0 copyfont
    } ifelse
} def	

/slantfont {	% FontName slant-degree  slantfont  font'
    exch findfont 1 copyfont begin
    [ 1 0 4 -1 roll 1 0 0 ] FontMatrix exch matrix concatmatrix
    /FontMatrix exch def
    currentdict
    end
} def

% Function print line number (<string> # -)
/# {
  gsave
    sx cw mul neg 2 div 0 rmoveto
    f# setfont
    c-show
  grestore
} bind def

% -------- Some routines to enlight plain b/w printings ---------

% Underline
% width --
/dounderline {
  currentpoint
  gsave
    moveto
    0 currentfont /Descent get currentfontsize mul rmoveto
    0 rlineto
    stroke
  grestore
} bind def

% Underline a string
% string --
/dounderlinestring {
  stringwidth pop
  dounderline
} bind def

/UL {
  /ul exch store
} bind def

% Draw a box of WIDTH wrt current font
% width --
/dobox {
  currentpoint
  gsave
    newpath
    moveto
    0 currentfont /Descent get currentfontsize mul rmoveto
    dup 0 rlineto
    0 currentfont /FontHeight get currentfontsize mul rlineto
    neg 0 rlineto
    closepath
    stroke
  grestore
} bind def

/BX {
  /bx exch store
} bind def

% Box a string
% string --
/doboxstring {
  stringwidth pop
  dobox
} bind def

%
% ------------- Color routines ---------------
%
/FG /setrgbcolor load def

% Draw the background
% width --
/dobackground {
  currentpoint
  gsave
    newpath
    moveto
    0 currentfont /Descent get currentfontsize mul rmoveto
    dup 0 rlineto
    0 currentfont /FontHeight get currentfontsize mul rlineto
    neg 0 rlineto
    closepath
    bgcolor aload pop setrgbcolor
    fill
  grestore
} bind def

% Draw bg for a string
% string --
/dobackgroundstring {
  stringwidth pop
  dobackground
} bind def


/BG {
  dup /bg exch store
  { mark 4 1 roll ] /bgcolor exch store } if
} bind def


/Show {
  bg { dup dobackgroundstring } if
  ul { dup dounderlinestring } if
  bx { dup doboxstring } if
  show
} bind def

% Function T(ab), jumps to the n-th tabulation in the current line
/T {
  cw mul x0 add
  bg { dup currentpoint pop sub dobackground } if
  ul { dup currentpoint pop sub dounderline } if
  bx { dup currentpoint pop sub dobox } if
  y0 moveto
} bind def

% Function n: move to the next line
/n {
  /y0 y0 bfs sub store
  x0 y0 moveto
} bind def

% Function N: show and move to the next line
/N {
  Show
  /y0 y0 bfs sub store
  x0 y0 moveto
} bind def

/S {
  Show
} bind def

%%BeginResource: procset a2ps-a2ps-hdr 2.0 2
%%Copyright: (c) 1988, 89, 90, 91, 92, 93 Miguel Santana
%%Copyright: (c) 1995, 96, 97, 98 Akim Demaille, Miguel Santana
% Function title: prints page header.
% <ct> <rt> <lt> are passed as argument
/title { 
  % 1. Draw the background
  x v get y v get moveto
  gsave
    0 th 2 div neg rmoveto 
    th setlinewidth
    0.95 setgray
    pw 0 rlineto stroke
  grestore
  % 2. Border it
  gsave
    0.7 setlinewidth
    pw 0 rlineto
    0 th neg rlineto
    pw neg 0 rlineto
    closepath stroke
  grestore
  % stk: ct rt lt
  x v get y v get th sub 1 add moveto
%%IncludeResource: font Helvetica
  fHelvetica fnfs 0.8 mul scalefont setfont
  % 3. The left title
  gsave
    dup stringwidth pop fnfs 0.8 mul add exch % leave space took on stack
    fnfs 0.8 mul hm rmoveto
    show			% left title
  grestore
  exch
  % stk: ct ltw rt
  % 4. the right title
  gsave
    dup stringwidth pop fnfs 0.8 mul add exch % leave space took on stack
    dup
    pw exch stringwidth pop fnfs 0.8 mul add sub
    hm
    rmoveto
    show			% right title
  grestore
  % stk: ct ltw rtw
  % 5. the center title
  gsave
    pw 3 1 roll
    % stk: ct pw ltw rtw
    3 copy 
    % Move to the center of the left room
    sub add 2 div hm rmoveto
    % What is the available space in here?
    add sub fnfs 0.8 mul sub fnfs 0.8 mul sub
    % stk: ct space_left
%%IncludeResource: font Helvetica-Bold
  fHelvetica-Bold fnfs scalefont setfont
    cfshow
  grestore
} bind def

% Function border: prints virtual page border
/border { %def
  gsave				% print four sides
    0 setgray
    x v get y v get moveto
    0.7 setlinewidth		% of the square
    pw 0 rlineto
    0 ph neg rlineto
    pw neg 0 rlineto
    closepath stroke
  grestore
} bind def

% Function water: prints a water mark in background
/water { %def
  gsave
    scx scy moveto rotate
%%IncludeResource: font Times-Bold
  fTimes-Bold 100 scalefont setfont
    .97 setgray
    dup stringwidth pop 2 div neg -50 rmoveto
    show
  grestore
} bind def

% Function rhead: prints the right header
/rhead {  %def
  lx ly moveto
  fHelvetica fnfs 0.8 mul scalefont setfont
  l-show
} bind def

% Function footer (cf rf lf -> -)
/footer {
  fHelvetica fnfs 0.8 mul scalefont setfont
  dx dy moveto
  show

  snx sny moveto
  l-show
  
  fnx fny moveto
  c-show
} bind def
%%EndResource
%%BeginResource: procset a2ps-black+white-Prolog 2.0 1

% Function T(ab), jumps to the n-th tabulation in the current line
/T { 
  cw mul x0 add y0 moveto
} bind def

% Function n: move to the next line
/n { %def
  /y0 y0 bfs sub store
  x0 y0 moveto
} bind def

% Function N: show and move to the next line
/N {
  Show
  /y0 y0 bfs sub store
  x0 y0 moveto
}  bind def

/S {
  Show
} bind def

/p {
  false UL
  false BX
  fCourier bfs scalefont setfont
  Show
} bind def

/sy {
  false UL
  false BX
  fSymbol bfs scalefont setfont
  Show
} bind def

/k {
  false UL
  false BX
  fCourier-Oblique bfs scalefont setfont
  Show
} bind def

/K {
  false UL
  false BX
  fCourier-Bold bfs scalefont setfont
  Show
} bind def

/c {
  false UL
  false BX
  fCourier-Oblique bfs scalefont setfont
  Show
} bind def

/C {
  false UL
  false BX
  fCourier-BoldOblique bfs scalefont setfont
  Show 
} bind def

/l {
  false UL
  false BX
  fHelvetica bfs scalefont setfont
  Show
} bind def

/L {
  false UL
  false BX
  fHelvetica-Bold bfs scalefont setfont
  Show 
} bind def

/str{
  false UL
  false BX
  fTimes-Roman bfs scalefont setfont
  Show
} bind def

/e{
  false UL
  true BX
  fHelvetica-Bold bfs scalefont setfont
  Show
} bind def

%%EndResource
%%EndProlog
%%BeginSetup
%%IncludeResource: font Courier
%%IncludeResource: font Courier-Oblique
%%IncludeResource: font Courier-Bold
%%IncludeResource: font Times-Roman
%%IncludeResource: font Symbol
%%IncludeResource: font Courier-BoldOblique
%%BeginResource: encoding ISO-8859-1Encoding
/ISO-8859-1Encoding [
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef 
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef 
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef 
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef 
/space /exclam /quotedbl /numbersign /dollar /percent /ampersand /quoteright 
/parenleft /parenright /asterisk /plus /comma /minus /period /slash 
/zero /one /two /three /four /five /six /seven 
/eight /nine /colon /semicolon /less /equal /greater /question 
/at /A /B /C /D /E /F /G 
/H /I /J /K /L /M /N /O 
/P /Q /R /S /T /U /V /W 
/X /Y /Z /bracketleft /backslash /bracketright /asciicircum /underscore 
/quoteleft /a /b /c /d /e /f /g 
/h /i /j /k /l /m /n /o 
/p /q /r /s /t /u /v /w 
/x /y /z /braceleft /bar /braceright /asciitilde /.notdef 
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef 
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef 
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef 
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef 
/space /exclamdown /cent /sterling /currency /yen /brokenbar /section 
/dieresis /copyright /ordfeminine /guillemotleft /logicalnot /hyphen /registered /macron 
/degree /plusminus /twosuperior /threesuperior /acute /mu /paragraph /bullet 
/cedilla /onesuperior /ordmasculine /guillemotright /onequarter /onehalf /threequarters /questiondown 
/Agrave /Aacute /Acircumflex /Atilde /Adieresis /Aring /AE /Ccedilla 
/Egrave /Eacute /Ecircumflex /Edieresis /Igrave /Iacute /Icircumflex /Idieresis 
/Eth /Ntilde /Ograve /Oacute /Ocircumflex /Otilde /Odieresis /multiply 
/Oslash /Ugrave /Uacute /Ucircumflex /Udieresis /Yacute /Thorn /germandbls 
/agrave /aacute /acircumflex /atilde /adieresis /aring /ae /ccedilla 
/egrave /eacute /ecircumflex /edieresis /igrave /iacute /icircumflex /idieresis 
/eth /ntilde /ograve /oacute /ocircumflex /otilde /odieresis /divide 
/oslash /ugrave /uacute /ucircumflex /udieresis /yacute /thorn /ydieresis 
] def
%%EndResource
% Initialize page description variables.
/sh 612 def
/sw 792 def
/llx 24 def
/urx 768 def
/ury 588 def
/lly 24 def
/#copies 1 def
/th 15.000000 def
/fnfs 11 def
/bfs 7.060185 def
/cw 4.236111 def

% Dictionary for ISO-8859-1 support
/iso1dict 8 dict begin
  /fCourier ISO-8859-1Encoding /Courier reencode_font
  /fCourier-Bold ISO-8859-1Encoding /Courier-Bold reencode_font
  /fCourier-BoldOblique ISO-8859-1Encoding /Courier-BoldOblique reencode_font
  /fCourier-Oblique ISO-8859-1Encoding /Courier-Oblique reencode_font
  /fHelvetica ISO-8859-1Encoding /Helvetica reencode_font
  /fHelvetica-Bold ISO-8859-1Encoding /Helvetica-Bold reencode_font
  /fTimes-Bold ISO-8859-1Encoding /Times-Bold reencode_font
  /fTimes-Roman ISO-8859-1Encoding /Times-Roman reencode_font
currentdict end def
/bgcolor [ 0 0 0 ] def
/bg false def
/ul false def
/bx false def
% The font for line numbering
/f# /Helvetica findfont bfs .6 mul scalefont def
/fSymbol /Symbol findfont def
/hm fnfs 0.25 mul def
/pw
   cw 86.400000 mul
def
/ph
   520.335631 th add
def
/pmw urx llx sub pw 2 mul sub 1 div def
/pmh 0 def
/v 0 def
/x [
  0
  dup pmw add pw add
] def
/y [
  pmh ph add 0 mul ph add
  dup
] def
/scx sw 2 div def
/scy sh 2 div def
/snx urx def
/sny lly 2 add def
/dx llx def
/dy sny def
/fnx scx def
/fny dy def
/lx snx def
/ly ury fnfs 0.8 mul sub def
/sx 5 def
/tab 8 def
/x0 0 def
/y0 0 def
%%EndSetup

%%Page: (1-2) 1
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 2.965278 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
0 T (/**) c n
0 T ( * @file nonbonded_outerloop.cc) N
0 T ( * template methods of Nonbonded_Outerloop.) N
0 T ( */) N
(5) # () N
0 T () S
(#ifdef) K
( XXMPI) p n
0 T () S
(#include) K
( <mpi.h>) p n
0 T () S
(#endif) K n
0 T () N
(10) # (#include) S
( ") p
(../../../stdheader.h) str
(") p n
0 T () N
0 T () S
(#include) K
( ") p
(../../../algorithm/algorithm.h) str
(") p n
0 T () S
(#include) K
( ") p
(../../../topology/topology.h) str
(") p n
0 T () S
(#include) K
( ") p
(../../../simulation/simulation.h) str
(") p n
(15) # () S
(#include) K
( ") p
(../../../configuration/configuration.h) str
(") p n
0 T () N
0 T () S
(#include) K
( ") p
(../../../interaction/interaction_types.h) str
(") p n
0 T () S
(#include) K
( ") p
(../../../math/periodicity.h) str
(") p n
0 T () S
(#include) K
( ") p
(../../../math/volume.h) str
(") p n
(20) # () N
0 T () S
(#include) K
( ") p
(../../../interaction/nonbonded/pairlist/pairlist.h) str
(") p n
0 T () S
(#include) K
( ") p
(../../../interaction/nonbonded/interaction/storage.h) str
(") p n
0 T () S
(#include) K
( ") p
(../../../interaction/nonbonded/interaction/nonbonded_parameter.h) str
(") p n
0 T () N
(25) # () S
(#include) K
( ") p
(../../../interaction/nonbonded/interaction/nonbonded_term.h) str
(") p n
0 T () S
(#include) K
( ") p
(../../../interaction/nonbonded/interaction/latticesum.h) str
(") p n
0 T () S
(#include) K
( ") p
(../../../configuration/mesh.h) str
(") p n
0 T () S
(#include) K
( ") p
(../../../interaction/nonbonded/interaction/nonbonded_innerloop.h) str
(") p n
0 T () N
(30) # () S
(#include) K
( ") p
(../../../interaction/nonbonded/interaction/nonbonded_outerloop.h) str
(") p n
0 T () N
0 T () S
(#include) K
( ") p
(../../../interaction/nonbonded/interaction_spec.h) str
(") p n
0 T () N
0 T () S
(#include) K
( ") p
(../../../util/debug.h) str
(") p n
(35) # () S
(#include) K
( ") p
(../../../interaction/nonbonded/innerloop_template.h) str
(") p n
0 T () N
0 T () S
(#include) K
( ") p
(../../../simulation/parameter.h) str
(") p n
0 T () N
0 T () S
(#include) K
( ") p
(storage.h) str
(") p n
(40) # () N
0 T () S
(#include) K
( ") p
(../../special/qmmm/mm_atom.h) str
(") p n
0 T () S
(#include) K
( ") p
(../../special/qmmm/qm_storage.h) str
(") p n
0 T () S
(#include) K
( ") p
(../../interaction.h) str
(") p n
0 T () S
(#include) K
( ") p
(../../special/qmmm_interaction.h) str
(") p n
(45) # () N
0 T () S
(#ifdef) K
( OMP) p n
0 T () S
(#include) K
( <omp.h>) p n
0 T () S
(#endif) K n
0 T () N
(50) # (#include) S
( <algorithm>) p n
0 T () N
0 T () S
(#undef) K
( MODULE) p n
0 T () S
(#undef) K
( SUBMODULE) p n
0 T () S
(#define) K
( MODULE interaction) p n
(55) # () S
(#define) K
( SUBMODULE nonbonded) p n
0 T () N
0 T () S
(/**) c n
0 T ( * Constructor.) N
0 T ( */) N
(60) # () S
(interaction::Nonbonded_Outerloop) p n
0 T (::Nonbonded_Outerloop\(Nonbonded_Parameter &nbp\)) N
0 T (: m_param\(nbp\) {) N
0 T (}) N
0 T () N
(65) # () S
(//==================================================) c n
0 T (// interaction loops) N
0 T (//==================================================) N
0 T () S
(int) k
( interaction::Nonbonded_Outerloop::calculate_interaction_off\(Nonbonded_Parame) p n
0 T (ter & param,) N
0 T (                  topology::Topology &topo, configuration::Configuration &conf,) N
(70) # (                  simulation::Simulation &sim, Pairlist ) S
(const) K
( & pairlist_solute,) p n
0 T (                  Pairlist ) S
(const) K
( & pairlist_solvent,) p n
0 T (                     math::VArray &force, math::VArray &virtual_f \) {) N
(nonbonded_outerloop.cc) (Page 1/40) (Dec 06, 18 14:53) title
border
/v 1 store
/x0 x v get 2.965278 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
0 T () p n
0 T (  std::vector< interaction::off_site_struct>::iterator) N
(75) # (          off_it=param.offsite_parameter\(\).begin\(\),) N
0 T (          off_to=param.offsite_parameter\(\).end\(\);) N
0 T () N
0 T (  ) S
(double) k
( q1,q2;) p n
0 T (  ) S
(double) k
( r1,r2;) p n
(80) # (  math::Vec f,dR;) N
0 T (  math::Periodicity<math::rectangular> periodicity\(conf.current\(\).box\);) N
0 T (  math::Vec R_off,F01,F02;) N
0 T (  ) S
(//compute force on virtual site due to presence of charged particles in the vi) c n
0 T (cinity) N
0 T () S
(  ) p
(//defined by the short-range pairlist) c n
(85) # () S
(  ) p
(const) K
( ) p
(double) k
( prefac=math::four_pi_eps_i;) p n
0 T (  ) S
(for) K
( \(;off_it!=off_to;++off_it\){) p n
0 T (      ) S
(//update positions of virtual sites) c n
0 T () S
(      R_off=off_it->va.pos\(conf,topo\);) p n
0 T (      q1=off_it->charge;) N
(90) # (      ) S
(unsigned) k
( ) p
(int) k
( p;) p n
0 T (      p = off_it->parents[0];) N
0 T (      ) S
(for) K
( \() p
(unsigned) k
( ) p
(int) k
( atom_j = 0;) p n
0 T (           atom_j < pairlist_solute[p].size\(\); ++atom_j\) {) N
0 T (        ) S
(const) K
( ) p
(int) k
( kk = periodicity.nearest_image\(R_off, conf.current\(\).pos\(atom_) p n
0 T (j\), dR\);) N
(95) # (        q2=topo.charge\(atom_j\);) N
0 T (        f=prefac*q1*q2*dR/\(abs\(dR\)*abs2\(dR\)\);) N
0 T (        F01=conf.current\(\).force\(p\);) N
0 T (        F02=conf.current\(\).force\(off_it->parents[1]\);) N
0 T (        off_it->va.force\(conf,topo,f\); ) S
(//distributed force to atoms i and j) c n
(100) # () S
(        virtual_f[off_it->parents[0]]=conf.current\(\).force\(off_it->parents[0]\)-F) p n
0 T (01;) N
0 T (        virtual_f[off_it->parents[1]]=conf.current\(\).force\(off_it->parents[1]\)-F) N
0 T (02;) N
0 T (        force[atom_j]=-f;) N
0 T (        ) S
(//    storage.energies.crf_energy[eg_i][eg_j] += e_crf;) c n
0 T (//    std::cout << "pairlist of "  << p  << m_nonbonded_set[p]->pairlist\(\).solut) N
0 T (e_short  << std::endl;) N
(105) # (//        std::cout << off_it->parents[0] << "   " << off_it->parents[1] << "  ") N
0 T ( << off_it->charge << std::endl;) N
0 T () S
(      }) p n
0 T (    }) N
0 T () N
0 T (  ) S
(return) K
(  0;) p n
(110) # (}) N
0 T () N
0 T () S
(void) k
( interaction::Nonbonded_Outerloop) p n
0 T (::lj_crf_outerloop\(topology::Topology & topo,) N
0 T (        configuration::Configuration & conf,) N
(115) # (        simulation::Simulation & sim,) N
0 T (        Pairlist ) S
(const) K
( & pairlist_solute,) p n
0 T (        Pairlist ) S
(const) K
( & pairlist_solvent,) p n
0 T (        Storage & storage,) N
0 T (        ) S
(bool) k
( longrange, util::Algorithm_Timer & timer, ) p
(bool) k
( master\) {) p n
(120) # (  SPLIT_INNERLOOP\(_lj_crf_outerloop, topo, conf, sim,) N
0 T (          pairlist_solute, pairlist_solvent, storage, longrange, timer, master\);) N
0 T (}) N
0 T () N
0 T () S
(/**) c n
(125) # ( * helper function to calculate forces and energies, ) N
0 T ( * stores them in the arrays pointed to by parameters) N
0 T ( * to make it usable for longrange calculations.) N
0 T ( */) N
0 T () S
(template) K
(<) p
(typename) k
( t_interaction_spec>) p n
(130) # () S
(void) k
( interaction::Nonbonded_Outerloop) p n
0 T (::_lj_crf_outerloop\(topology::Topology & topo,) N
0 T (        configuration::Configuration & conf,) N
0 T (        simulation::Simulation & sim,) N
0 T (        Pairlist ) S
(const) K
( & pairlist_solute,) p n
(135) # (        Pairlist ) S
(const) K
( & pairlist_solvent,) p n
0 T (        Storage & storage, ) S
(bool) k
( longrange,) p n
0 T (        util::Algorithm_Timer & timer, ) S
(bool) k
( master\) {) p n
0 T (  DEBUG\(7, ") S
(\\tcalculate interactions) str
("\);) p n
0 T () N
(nonbonded_outerloop.cc) (Page 2/40) (Dec 06, 18 14:53) title
border
grestore
(Printed by Patrick Bleiziffer) rhead
(nonbonded_outerloop.cc) (1/20) (Thursday December 06, 2018) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (3-4) 2
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 2.965278 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(140) # (  ) p
(// WORKAROUND! See definition of _lj_crf_outerloop_fast) c n
0 T () S
(  ) p
(if) K
( \(t_interaction_spec::boundary_type == math::rectangular &&) p n
0 T (      t_interaction_spec::interaction_func == simulation::lj_crf_func &&) N
0 T (      sim.param\(\).innerloop.method != simulation::sla_cuda\) {) N
0 T (    _lj_crf_outerloop_fast\(topo, conf, sim, pairlist_solute, pairlist_solvent,) N
(145) # (                        storage, longrange, timer, master\);) N
0 T (    ) S
(return) K
(;) p n
0 T (  }) N
0 T () N
0 T (  math::Periodicity<t_interaction_spec::boundary_type> periodicity\(conf.current\() N
0 T (\).box\);) N
(150) # (  Nonbonded_Innerloop<t_interaction_spec> innerloop\(m_param\);) N
0 T (  innerloop.init\(sim\);) N
0 T () N
0 T (  ) S
(/*) c n
0 T (    variables for a OMP parallelizable loop.) N
(155) # (    outer index has to be integer...) N
0 T (   */) N
0 T () S
(  std::vector<) p
(unsigned) k
( ) p
(int) k
(>::const_iterator j_it, j_to;) p n
0 T () N
0 T (  ) S
(unsigned) k
( ) p
(int) k
( size_i = ) p
(unsigned) k
(\(pairlist_solute.size\(\)\);) p n
(160) # (  DEBUG\(10, ") S
(lj_crf_outerloop pairlist size ) str
(" << size_i\);) p n
0 T () N
0 T (  ) S
(const) K
( ) p
(unsigned) k
( ) p
(int) k
( end = topo.num_solute_atoms\(\);) p n
0 T () N
0 T (  ) S
(unsigned) k
( ) p
(int) k
( i;) p n
(165) # (  ) S
(for) K
( \(i = 0; i < end; ++i\) {) p n
0 T (    ) S
(for) K
( \(j_it = pairlist_solute[i].begin\(\),) p n
0 T (            j_to = pairlist_solute[i].end\(\);) N
0 T (            j_it != j_to;) N
0 T (            ++j_it\) {) N
(170) # () N
0 T (      DEBUG\(10, ") S
(\\tnonbonded_interaction: i ) str
(" << i << ") p
( j ) str
(" << *j_it\);) p n
0 T () N
0 T (      ) S
(// shortrange, therefore store in simulation.system\(\)) c n
0 T () S
(      innerloop.lj_crf_innerloop\(topo, conf, i, *j_it, storage, periodicity\);) p n
(175) # (    }) N
0 T (  }) N
0 T () S
(/*only for DEBUG*/) c n
0 T () S
( ) p
(/* DEBUG\(1,"current solute pairlist:\\n"\);) c n
0 T (unsigned int i_deb;) N
(180) # (  for \(i_deb=0; i_deb < end; ++i_deb\) {) N
0 T (    for \(j_it = pairlist_solute[i_deb].begin\(\),) N
0 T (            j_to = pairlist_solute[i_deb].end\(\);) N
0 T (            j_it < j_to;) N
0 T (            j_it++\) {) N
(185) # (      //DEBUG\(10, "i " << i_deb << " j " << *j_it << " i " << topo.solvent\(0\).at) N
0 T (om\(i_deb\).name << " j " << topo.solvent\(0\).atom\(*j_it\).name\);) N
0 T (      DEBUG\(1, "i " << i_deb << " j " << *j_it\);) N
0 T (    }) N
0 T (  }) N
0 T (  DEBUG\(1,"current solvent pairlist:\\n"\);) N
(190) # (  for \(; i_deb < size_i; ++i_deb\) {) N
0 T (    for \(j_it = pairlist_solvent[i_deb].begin\(\),) N
0 T (            j_to = pairlist_solvent[i_deb].end\(\);) N
0 T (            j_it < j_to;) N
0 T (            j_it++\) {) N
(195) # (      //DEBUG\(10, "i " << i_deb << " j " << *j_it << " i " << topo.solvent\(0\).at) N
0 T (om\(i_deb\).name << " j " << topo.solvent\(0\).atom\(*j_it\).name\);) N
0 T (      DEBUG\(1, "i " << i_deb << " j " << *j_it\);) N
0 T (    }) N
0 T (  }) N
0 T (  */) N
(200) # (/*DEBUG end*/) N
0 T () N
0 T () S
(  ) p
(// cuda doesn't do solvent-solvent here) c n
0 T () S
(  ) p
(if) K
( \(sim.param\(\).innerloop.method == simulation::sla_cuda\) ) p
(return) K
(;) p n
0 T (  ) S
(// solvent-solvent) c n
(205) # () S
(  ) p
(const) K
( std::string timer_name\(longrange ? ") p
(longrange solvent-solvent) str
(" : ") p
(solvent-solvent) str
("\)) p n
0 T (;) N
0 T (  ) S
(if) K
( \(master\)) p n
0 T (    timer.start\(timer_name\);) N
0 T (  ) S
(if) K
( \(sim.param\(\).force.special_loop == simulation::special_loop_spc\) { ) p
(// speci) c n
(nonbonded_outerloop.cc) (Page 3/40) (Dec 06, 18 14:53) title
border
/v 1 store
/x0 x v get 2.965278 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
0 T (al solvent loop) c n
0 T () S
(    ) p
(// solvent - solvent with spc innerloop...) c n
(210) # () S
(    ) p
(for) K
( \(; i < size_i; i += 3\) { ) p
(// use every third pairlist \(OW's\)) c n
0 T () S
(      ) p
(for) K
( \(j_it = pairlist_solvent[i].begin\(\),) p n
0 T (              j_to = pairlist_solvent[i].end\(\);) N
0 T (              j_it != j_to;) N
0 T (              j_it += 3\) { ) S
(// use every third atom \(OW\) in pairlist i) c n
(215) # () N
0 T () S
(        DEBUG\(10, ") p
(\\tsolvent-solvent longrange spc_nonbonded_interaction: i ) str
(" << i << ") p
( j ) str
(" << *j_i) p n
0 T (t\);) N
0 T () N
0 T (        innerloop.spc_innerloop\(topo, conf, i, *j_it, storage, periodicity\);) N
0 T (      }) N
(220) # (    } ) N
0 T (  } ) S
(else) K
( ) p
(if) K
( \(sim.param\(\).force.special_loop == simulation::special_loop_spc_tabl) p n
0 T (e\) { ) S
(// special solvent loop) c n
0 T () S
(    ) p
(// solvent - solvent with tabulated spc innerloop...) c n
0 T () S
(    ) p
(if) K
( \(longrange\) {) p n
0 T (      ) S
(// here we call the longrange function that uses a smaller table) c n
(225) # () S
(      ) p
(for) K
( \(; i < size_i; i += 3\) { ) p
(// use every third pairlist \(OW's\)) c n
0 T () S
(        ) p
(for) K
( \(j_it = pairlist_solvent[i].begin\(\),) p n
0 T (                j_to = pairlist_solvent[i].end\(\);) N
0 T (                j_it != j_to;) N
0 T (                j_it += 3\) { ) S
(// use every third atom \(OW\) in pairlist i) c n
(230) # () N
0 T () S
(          DEBUG\(10, ") p
(\\tsolvent-solvent \(tabulated\) longrange spc_nonbonded_interaction: i ) str
(" << i << ") p
( j) str n
0 T ( ) S
(" << *j_it\);) p n
0 T (          ) S
(//innerloop.spc_innerloop\(topo, conf, i, *j_it, storage, periodicity\);) c n
0 T () S
(          innerloop.longrange_spc_table_innerloop\(topo, conf, i, *j_it, storage,) p n
0 T ( periodicity\);) N
0 T (        }) N
(235) # (      }) N
0 T (    } ) S
(else) K
( { ) p
(// shortrange) c n
0 T () S
(      ) p
(for) K
( \(; i < size_i; i += 3\) { ) p
(// use every third pairlist \(OW's\)) c n
0 T () S
(        ) p
(for) K
( \(j_it = pairlist_solvent[i].begin\(\),) p n
0 T (                j_to = pairlist_solvent[i].end\(\);) N
(240) # (                j_it != j_to;) N
0 T (                j_it += 3\) { ) S
(// use every third atom \(OW\) in pairlist i) c n
0 T () N
0 T () S
(          DEBUG\(10, ") p
(\\tsolvent-solvent \(tabulated\) shortrange spc_nonbonded_interaction: i ) str
(" << i << ") p
( ) str n
0 T (j ) S
(" << *j_it\);) p n
0 T (          ) S
(//innerloop.spc_innerloop\(topo, conf, i, *j_it, storage, periodicity\);) c n
(245) # () S
(          innerloop.shortrange_spc_table_innerloop\(topo, conf, i, *j_it, storage) p n
0 T (, periodicity\);) N
0 T (        }) N
0 T (      }) N
0 T (    }) N
0 T (  } ) S
(else) K
( ) p
(if) K
( \(sim.param\(\).force.special_loop == simulation::special_loop_generic\)) p n
0 T ( {) N
(250) # (    ) S
(const) K
( ) p
(unsigned) k
( ) p
(int) k
( num_solvent_atoms = topo.solvent\(0\).num_atoms\(\);) p n
0 T (    ) S
(// prepare parameters) c n
0 T () S
(    ) p
(const) K
( ) p
(unsigned) k
( ) p
(int) k
( num_param = num_solvent_atoms * num_solvent_atoms;) p n
0 T (    ) S
(typename) k
( interaction::Nonbonded_Innerloop<t_interaction_spec>::solvent_pair_) p n
0 T (parameter pair_parameter[num_param];) N
0 T () N
(255) # (    ) S
(unsigned) k
( ) p
(int) k
( param = 0;) p n
0 T (    ) S
(for) K
( \() p
(unsigned) k
( ) p
(int) k
( atom_i = 0; atom_i < num_solvent_atoms; ++atom_i\) {) p n
0 T (      ) S
(for) K
( \() p
(unsigned) k
( ) p
(int) k
( atom_j = 0; atom_j < num_solvent_atoms; ++atom_j, ++para) p n
0 T (m\) {) N
0 T (        assert\(param < num_param\);) N
0 T (        DEBUG\(10, ") S
(\\tsolvent pair parameter: ) str
(" << param\);) p n
(260) # () N
0 T (        ) S
(const) K
( lj_parameter_struct & lj =) p n
0 T (                innerloop.param\(\)->lj_parameter\(topo.solvent\(0\).atom\(atom_i\).iac) N
0 T (, topo.solvent\(0\).atom\(atom_j\).iac\);) N
0 T (        pair_parameter[param].c12 = lj.c12;) N
0 T (        pair_parameter[param].c6 = lj.c6;) N
(265) # () N
0 T (        pair_parameter[param].q = math::four_pi_eps_i *) N
0 T (                topo.solvent\(0\).atom\(atom_i\).charge *) N
0 T (                topo.solvent\(0\).atom\(atom_j\).charge;) N
0 T () N
(270) # (        DEBUG\(10, ") S
(\\t\\tc12: ) str
(" << pair_parameter[param].c12 << ") p
( c6: ) str
(" <<) p n
(nonbonded_outerloop.cc) (Page 4/40) (Dec 06, 18 14:53) title
border
grestore
(Printed by Patrick Bleiziffer) rhead
(nonbonded_outerloop.cc) (2/20) (Thursday December 06, 2018) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (5-6) 3
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 2.965278 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
0 T (                pair_parameter[param].c6 << ") p
( q: ) str
(" << pair_parameter[param].q\);) p n
0 T (      }) N
0 T (    }) N
0 T () N
(275) # (    ) S
(// use num_solvent_atoms-th atom \(first of solvent molecule i\)) c n
0 T () S
(    ) p
(for) K
( \(; i < size_i; i += num_solvent_atoms\) {) p n
0 T (      ) S
(for) K
( \(j_it = pairlist_solvent[i].begin\(\),) p n
0 T (              j_to = pairlist_solvent[i].end\(\);) N
0 T (              j_it != j_to;) N
(280) # (              j_it += num_solvent_atoms\) { ) S
(// use num_solvent_atoms-th atom \(fir) c n
0 T (st of solvent molecule j\)) N
0 T () N
0 T () S
(        DEBUG\(10, ") p
(\\tsolvent_nonbonded_interaction \(special_loop_generic\): i ) str
(" << i << ") p
( j ) str
(" << *j_i) p n
0 T (t\);) N
0 T () N
0 T (        innerloop.solvent_innerloop\(topo, pair_parameter, conf, num_solvent_atom) N
0 T (s, i, *j_it, storage, periodicity\);) N
(285) # (      }) N
0 T (    }) N
0 T (  } ) S
(else) K
( { ) p
(// normal solvent loop) c n
0 T () S
(    ) p
(for) K
( \(; i < size_i; ++i\) {) p n
0 T (      ) S
(for) K
( \(j_it = pairlist_solvent[i].begin\(\),) p n
(290) # (              j_to = pairlist_solvent[i].end\(\);) N
0 T (              j_it != j_to;) N
0 T (              ++j_it\) {) N
0 T () N
0 T (        DEBUG\(10, ") S
(\\tsolvent_nonbonded_interaction \(normal solvent loop\): i ) str
(" << i << ") p
( j ) str
(" << *j_it) p n
0 T (\);) N
(295) # () N
0 T (        innerloop.lj_crf_innerloop\(topo, conf, i, *j_it, storage, periodicity\);) N
0 T (      }) N
0 T (    }) N
0 T (  }) N
(300) # (  ) S
(if) K
( \(master\)) p n
0 T (    timer.stop\(timer_name\);) N
0 T (}) N
0 T () N
0 T () N
(305) # () S
(/**) c n
0 T ( * helper function to calculate forces and energies, ) N
0 T ( * stores them in the arrays pointed to by parameters) N
0 T ( * to make it usable for longrange calculations.) N
0 T ( */) N
(310) # (// WORKAROUND - see definition!) N
0 T () S
(void) k
( interaction::Nonbonded_Outerloop) p n
0 T (::_lj_crf_outerloop_fast\(topology::Topology & topo,) N
0 T (        configuration::Configuration & conf,) N
0 T (        simulation::Simulation & sim,) N
(315) # (        Pairlist ) S
(const) K
( & pairlist_solute,) p n
0 T (        Pairlist ) S
(const) K
( & pairlist_solvent,) p n
0 T (        Storage & storage, ) S
(bool) k
( longrange,) p n
0 T (        util::Algorithm_Timer & timer, ) S
(bool) k
( master\) {) p n
0 T (  DEBUG\(7, ") S
(\\tcalculate interactions lj_crf_outerloop_fast) str
("\);) p n
(320) # () N
0 T (  math::Periodicity<math::rectangular> periodicity\(conf.current\(\).box\);) N
0 T (  periodicity.recalc_shift_vectors\(\);) N
0 T (  Nonbonded_Innerloop<interaction::Interaction_Spec<math::rectangular, simulatio) N
0 T (n::lj_crf_func> > innerloop\(m_param\);) N
0 T (  innerloop.init\(sim\);) N
(325) # () N
0 T (  ) S
(/*) c n
0 T (    variables for a OMP parallelizable loop.) N
0 T (    outer index has to be integer...) N
0 T (   */) N
(330) # () S
(    math::VArray f_off;  ) p
(//contains force caused by virt. site on all others) c n
0 T () S
(    math::VArray virtual_off; ) p
(//contains also forces caused by others to virt. s) c n
0 T (ite) N
0 T () S
(    ) p
(//force on virt. site is distributed over its parents i and j) c n
0 T () S
(    f_off.resize\(topo.num_solute_atoms\(\)\);) p n
0 T (    virtual_off.resize\(topo.num_solute_atoms\(\)\);) N
(335) # (    f_off=0.;) N
0 T (    virtual_off=0.0;) N
0 T (    ) S
(if) K
( \(m_param.offsite_parameter\(\).size\(\)!=0\){) p n
(nonbonded_outerloop.cc) (Page 5/40) (Dec 06, 18 14:53) title
border
/v 1 store
/x0 x v get 2.965278 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
0 T (         calculate_interaction_off\(m_param,topo,conf,sim,pairlist_solute,pairlis) p n
0 T (t_solvent,) N
0 T (                              f_off,virtual_off\);) N
(340) # (    }) N
0 T () N
0 T (  std::vector<) S
(unsigned) k
( ) p
(int) k
(>::const_iterator j_it, j_to;) p n
0 T () N
0 T (  ) S
(unsigned) k
( ) p
(int) k
( size_i = ) p
(unsigned) k
(\(pairlist_solute.size\(\)\);) p n
(345) # (  DEBUG\(10, ") S
(lj_crf2 outerloop pairlist size ) str
(" << size_i\);) p n
0 T () N
0 T (  ) S
(const) K
( ) p
(unsigned) k
( ) p
(int) k
( end = topo.num_solute_atoms\(\);) p n
0 T () N
0 T (  ) S
(unsigned) k
( ) p
(int) k
( i;) p n
(350) # (  ) S
(for) K
( \(i = 0; i < end; ++i\) {) p n
0 T (    ) S
(const) K
( math::Vec posI = conf.current\(\).pos\(i\);) p n
0 T (    ) S
(const) K
( ) p
(unsigned) k
( ) p
(int) k
( eg_i = topo.atom_energy_group\(i\);) p n
0 T (    math::Vec groupForce\(0.0\);) N
0 T (    ) S
(int) k
( k = 0;) p n
(355) # (    ) N
0 T () N
0 T (    ) S
(// shortrange, therefore store in simulation.system\(\)) c n
0 T () S
(    ) p
(for) K
( \(j_it = pairlist_solute[i].begin\(\),) p n
0 T (         j_to = pairlist_solute[i].end\(\);) N
(360) # (         j_it != j_to;) N
0 T (         ++j_it\) {) N
0 T (      DEBUG\(10, ") S
(\\tnonbonded_interaction: i ) str
(" << i << ") p
( j ) str
(" << *j_it\);) p n
0 T (            ) N
0 T (      math::Vec r;) N
(365) # (      ) S
(const) K
( ) p
(int) k
( kk = periodicity.nearest_image\(posI, conf.current\(\).pos\(*j_it\), ) p n
0 T (r\);) N
0 T (      ) N
0 T (      ) S
(if) K
( \(kk != k\) {) p n
0 T (        storage.force\(i\) += groupForce;) N
0 T (        groupForce+=virtual_off\(i\); ) S
(//add contributions from ijkl) c n
(370) # () S
(                                   ) p
(//ij are the parents of the virtual site) c n
0 T () S
(                                   ) p
(//kl runs over all other particels) c n
0 T () S
(        storage.force\(i\)+=f_off\(i\); ) p
(//add only kl,since ij are already taken car) c n
0 T (e of) N
0 T () S
(        groupForce+=f_off\(i\); ) p
(//add only kl,since ij are already taken care of) c n
0 T () S
(        ) p
(if) K
( \(k != 0\) {) p n
(375) # (          ) S
(const) K
( math::Vec shift = periodicity.shift\(k+13\).pos;) p n
0 T (          ) S
(for) K
( \() p
(int) k
( a = 0; a < 3; ++a\) {) p n
0 T (            ) S
(for) K
( \() p
(int) k
( b = 0; b < 3; ++b\) {) p n
0 T (              ) S
(//storage.virial_tensor\(b, a\) += \(posI\(b\) + shift\(b\)\) * groupForce) c n
0 T (\(a\);) N
0 T () S
(              storage.virial_tensor\(b, a\) += shift\(b\) * groupForce\(a\);) p n
(380) # (            }) N
0 T (          }) N
0 T (        }) N
0 T (        groupForce = 0.;) N
0 T (        k = kk;) N
(385) # (        ) N
0 T (      }) N
0 T (      ) N
0 T (      ) S
(const) K
( ) p
(double) k
( dist2 = abs2\(r\);) p n
0 T (      math::Vec force;) N
(390) # (      ) S
(double) k
( f;) p n
0 T (      ) S
(double) k
( e_lj, e_crf;) p n
0 T (      ) N
0 T (      innerloop.lj_crf_innerloop_2\(topo, i, *j_it, dist2, f, e_lj, e_crf\);      ) N
0 T (      ) N
(395) # (      ) S
(const) K
( ) p
(unsigned) k
( ) p
(int) k
( eg_j = topo.atom_energy_group\(*j_it\);) p n
0 T (      DEBUG\(11, ") S
(\\tenergy group i ) str
(" << eg_i << ") p
( j ) str
(" << eg_j\);) p n
0 T (      storage.energies.lj_energy[eg_i][eg_j] += e_lj;) N
0 T (      storage.energies.crf_energy[eg_i][eg_j] += e_crf;) N
0 T (            ) N
(400) # (      force = f * r;) N
0 T (      storage.force\(*j_it\) -= force;) N
0 T (      groupForce += force;) N
0 T (      ) N
0 T (      ) S
(// shortrange, therefore store in simulation.system\(\)) c n
(405) # () S
(      ) p
(// innerloop.lj_crf_innerloop\(topo, conf, i, *j_it, storage, periodicity\);) c n
0 T () S
(    }) p n
(nonbonded_outerloop.cc) (Page 6/40) (Dec 06, 18 14:53) title
border
grestore
(Printed by Patrick Bleiziffer) rhead
(nonbonded_outerloop.cc) (3/20) (Thursday December 06, 2018) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (7-8) 4
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 2.965278 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
0 T (    groupForce+=f_off\(i\);) p n
0 T (    storage.force\(i\) += groupForce;) N
0 T (    groupForce+=virtual_off\(i\); ) S
(//add contributions from ijkl) c n
(410) # () S
(    ) p
(//ij are the parents of the virtual site) c n
0 T () S
(    ) p
(//kl runs over all other particles) c n
0 T () S
(    ) p
(if) K
( \(k != 0\) {) p n
0 T (      ) S
(const) K
( math::Vec shift = periodicity.shift\(k+13\).pos;) p n
0 T (      ) S
(for) K
( \() p
(int) k
( a = 0; a < 3; ++a\) {) p n
(415) # (        ) S
(for) K
( \() p
(int) k
( b = 0; b < 3; ++b\) {) p n
0 T (          ) S
(//storage.virial_tensor\(b, a\) += \(posI\(b\) + shift\(b\)\) * groupForce\(a\);) c n
0 T () S
(          storage.virial_tensor\(b, a\) += shift\(b\) * groupForce\(a\);) p n
0 T (        }) N
0 T (      }) N
(420) # (    }) N
0 T (  }) N
0 T (    ) N
0 T (  ) S
(for) K
( \() p
(unsigned) k
( ) p
(int) k
( ii = 0; ii < topo.num_solute_atoms\(\); ++ii\) {) p n
0 T (    ) S
(const) K
( math::Vec pos = conf.current\(\).pos\(ii\);) p n
(425) # (    ) S
(const) K
( math::Vec force = storage.force\(ii\) + virtual_off\(ii\);) p n
0 T (    ) S
(for) K
( \() p
(int) k
( a = 0; a < 3; ++a\) {) p n
0 T (      ) S
(for) K
( \() p
(int) k
( b = 0; b < 3; ++b\) {) p n
0 T (        ) S
(//storage.virial_tensor\(b, a\) += \(posI\(b\) + shift\(b\)\) * groupForce\(a\);) c n
0 T () S
(        storage.virial_tensor\(b, a\) += pos\(b\) * force\(a\);) p n
(430) # (      }) N
0 T (    }) N
0 T (  }) N
0 T () S
(/*only for DEBUG*/) c n
0 T () S
( ) p
(/* DEBUG\(1,"current solute pairlist:\\n"\);) c n
(435) # (unsigned int i_deb;) N
0 T (  for \(i_deb=0; i_deb < end; ++i_deb\) {) N
0 T (    for \(j_it = pairlist_solute[i_deb].begin\(\),) N
0 T (            j_to = pairlist_solute[i_deb].end\(\);) N
0 T (            j_it < j_to;) N
(440) # (            j_it++\) {) N
0 T (      //DEBUG\(10, "i " << i_deb << " j " << *j_it << " i " << topo.solvent\(0\).at) N
0 T (om\(i_deb\).name << " j " << topo.solvent\(0\).atom\(*j_it\).name\);) N
0 T (      DEBUG\(1, "i " << i_deb << " j " << *j_it\);) N
0 T (    }) N
0 T (  }) N
(445) # (  DEBUG\(1,"current solvent pairlist:\\n"\);) N
0 T (  for \(; i_deb < size_i; ++i_deb\) {) N
0 T (    for \(j_it = pairlist_solvent[i_deb].begin\(\),) N
0 T (            j_to = pairlist_solvent[i_deb].end\(\);) N
0 T (            j_it < j_to;) N
(450) # (            j_it++\) {) N
0 T (      //DEBUG\(10, "i " << i_deb << " j " << *j_it << " i " << topo.solvent\(0\).at) N
0 T (om\(i_deb\).name << " j " << topo.solvent\(0\).atom\(*j_it\).name\);) N
0 T (      DEBUG\(1, "i " << i_deb << " j " << *j_it\);) N
0 T (    }) N
0 T (  }) N
(455) # (  */) N
0 T (/*DEBUG end*/) N
0 T () N
0 T () S
(  ) p
(// cuda doesn't do solvent-solvent here) c n
0 T () S
(  ) p
(if) K
( \(sim.param\(\).innerloop.method == simulation::sla_cuda\) ) p
(return) K
(;) p n
(460) # (  ) S
(// solvent-solvent) c n
0 T () S
(  ) p
(const) K
( std::string timer_name\(longrange ? ") p
(longrange solvent-solvent) str
(" : ") p
(solvent-solvent) str
("\)) p n
0 T (;) N
0 T (  ) S
(if) K
( \(master\)) p n
0 T (    timer.start\(timer_name\);) N
0 T (  ) S
(if) K
( \(sim.param\(\).force.special_loop == simulation::special_loop_spc\) { ) p
(// speci) c n
0 T (al solvent loop) N
(465) # () S
(    ) p
(// solvent - solvent with spc innerloop...) c n
0 T () N
0 T () S
(    ) p
(// only one energy group) c n
0 T () S
(    ) p
(const) K
( ) p
(int) k
( egroup = topo.atom_energy_group\(topo.num_solute_atoms\(\)\);) p n
0 T () N
(470) # (    ) S
(for) K
( \(; i < size_i; i += 3\) { ) p
(// use every third pairlist \(OW's\)) c n
0 T () N
0 T () S
(      ) p
(const) K
( math::Vec posI  = conf.current\(\).pos\(i\);) p n
0 T (      ) S
(const) K
( math::Vec posI1 = conf.current\(\).pos\(i + 1\);) p n
0 T (      ) S
(const) K
( math::Vec posI2 = conf.current\(\).pos\(i + 2\);) p n
(475) # (      math::Vec groupForce0\(0.0\);) N
(nonbonded_outerloop.cc) (Page 7/40) (Dec 06, 18 14:53) title
border
/v 1 store
/x0 x v get 2.965278 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
0 T (      math::Vec groupForce1\(0.0\);) p n
0 T (      math::Vec groupForce2\(0.0\);) N
0 T (      ) S
(int) k
( k = 0;) p n
0 T (      math::Vec shift = periodicity.shift\(k + 13\).pos;) N
(480) # (      ) S
(double) k
( tx = shift\(0\), ty = shift\(1\), tz = shift\(2\);) p n
0 T () N
0 T (      ) S
(double) k
( dist6i;) p n
0 T (      ) S
(double) k
( e_lj = 0., e_crf = 0.;) p n
0 T (      ) S
(double) k
( r2[9], r2i[9], ri[9], x[9], y[9], z[9], f[9], fx[9], fy[9], fz[9];) p n
(485) # (      math::Vec r;) N
0 T () N
0 T (      ) S
(for) K
( \(j_it = pairlist_solvent[i].begin\(\),) p n
0 T (          j_to = pairlist_solvent[i].end\(\);) N
0 T (          j_it != j_to;) N
(490) # (          j_it += 3\) { ) S
(// use every third atom \(OW\) in pairlist i) c n
0 T () N
0 T () S
(        DEBUG\(10, ") p
(\\tsolvent-solvent spc_nonbonded_interaction: i ) str
(" << i << ") p
( j ) str
(" << *j_it\);) p n
0 T () N
0 T (        ) S
(const) K
( ) p
(int) k
( kk = periodicity.nearest_image\(posI, conf.current\(\).pos\(*j_it\)) p n
0 T (, r\);) N
(495) # () N
0 T (        ) S
(if) K
( \(kk != k\) {) p n
0 T (          storage.force\(i\) += groupForce0;) N
0 T (          storage.force\(i + 1\) += groupForce1;) N
0 T (          storage.force\(i + 2\) += groupForce2;) N
(500) # (          ) N
0 T (          ) S
(if) K
( \(k != 0\) {) p n
0 T (            ) S
(for) K
( \() p
(int) k
( a = 0; a < 3; ++a\) {) p n
0 T (              ) S
(for) K
( \() p
(int) k
( b = 0; b < 3; ++b\) {) p n
0 T (                ) S
(//storage.virial_tensor\(b, a\) += \(posI\(b\) + shift\(b\)\) * groupFor) c n
0 T (ce\(a\);) N
(505) # () S
(                storage.virial_tensor\(b, a\) += shift\(b\) * \(groupForce0\(a\) + grou) p n
0 T (pForce1\(a\) + groupForce2\(a\)\);) N
0 T (              }) N
0 T (            }) N
0 T (          }) N
0 T (          ) N
(510) # (          groupForce0 = 0.;) N
0 T (          groupForce1 = 0.;) N
0 T (          groupForce2 = 0.;) N
0 T (          k = kk;) N
0 T (          shift = periodicity.shift\(k + 13\).pos;) N
(515) # (          tx = shift\(0\);) N
0 T (          ty = shift\(1\);) N
0 T (          tz = shift\(2\);) N
0 T (        }) N
0 T () N
(520) # (        math::Vec ) S
(const) K
( * ) p
(const) K
( pos_j = &conf.current\(\).pos\(*j_it\);) p n
0 T (        math::Vec * ) S
(const) K
( force_j = &storage.force\(*j_it\);) p n
0 T () N
0 T (        x[0] = r\(0\);) N
0 T (        y[0] = r\(1\);) N
(525) # (        z[0] = r\(2\);) N
0 T () N
0 T (        x[1] = posI\(0\) - \(*\(pos_j + 1\)\)\(0\) + tx;) N
0 T (        y[1] = posI\(1\) - \(*\(pos_j + 1\)\)\(1\) + ty;) N
0 T (        z[1] = posI\(2\) - \(*\(pos_j + 1\)\)\(2\) + tz;) N
(530) # () N
0 T (        x[2] = posI\(0\) - \(*\(pos_j + 2\)\)\(0\) + tx;) N
0 T (        y[2] = posI\(1\) - \(*\(pos_j + 2\)\)\(1\) + ty;) N
0 T (        z[2] = posI\(2\) - \(*\(pos_j + 2\)\)\(2\) + tz;) N
0 T () N
(535) # (        x[3] = posI1\(0\) - \(*\(pos_j\)\)\(0\) + tx;) N
0 T (        y[3] = posI1\(1\) - \(*\(pos_j\)\)\(1\) + ty;) N
0 T (        z[3] = posI1\(2\) - \(*\(pos_j\)\)\(2\) + tz;) N
0 T () N
0 T (        x[4] = posI2\(0\) - \(*\(pos_j\)\)\(0\) + tx;) N
(540) # (        y[4] = posI2\(1\) - \(*\(pos_j\)\)\(1\) + ty;) N
0 T (        z[4] = posI2\(2\) - \(*\(pos_j\)\)\(2\) + tz;) N
0 T () N
0 T (        x[5] = posI1\(0\) - \(*\(pos_j + 1\)\)\(0\) + tx;) N
0 T (        y[5] = posI1\(1\) - \(*\(pos_j + 1\)\)\(1\) + ty;) N
(545) # (        z[5] = posI1\(2\) - \(*\(pos_j + 1\)\)\(2\) + tz;) N
(nonbonded_outerloop.cc) (Page 8/40) (Dec 06, 18 14:53) title
border
grestore
(Printed by Patrick Bleiziffer) rhead
(nonbonded_outerloop.cc) (4/20) (Thursday December 06, 2018) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (9-10) 5
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 2.965278 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
0 T () p n
0 T (        x[6] = posI1\(0\) - \(*\(pos_j + 2\)\)\(0\) + tx;) N
0 T (        y[6] = posI1\(1\) - \(*\(pos_j + 2\)\)\(1\) + ty;) N
0 T (        z[6] = posI1\(2\) - \(*\(pos_j + 2\)\)\(2\) + tz;) N
(550) # () N
0 T (        x[7] = posI2\(0\) - \(*\(pos_j + 1\)\)\(0\) + tx;) N
0 T (        y[7] = posI2\(1\) - \(*\(pos_j + 1\)\)\(1\) + ty;) N
0 T (        z[7] = posI2\(2\) - \(*\(pos_j + 1\)\)\(2\) + tz;) N
0 T () N
(555) # (        x[8] = posI2\(0\) - \(*\(pos_j + 2\)\)\(0\) + tx;) N
0 T (        y[8] = posI2\(1\) - \(*\(pos_j + 2\)\)\(1\) + ty;) N
0 T (        z[8] = posI2\(2\) - \(*\(pos_j + 2\)\)\(2\) + tz;) N
0 T () N
0 T (        ) S
(for) K
( \() p
(int) k
( ii = 0; ii < 9; ++ii\) {) p n
(560) # (          r2[ii] = x[ii] * x[ii] + y[ii] * y[ii] + z[ii] * z[ii];) N
0 T (          r2i[ii] = 1.0 / r2[ii];) N
0 T (          ri[ii] = sqrt\(r2i[ii]\);) N
0 T (        }) N
0 T () N
(565) # (        dist6i = r2i[0] * r2i[0] * r2i[0];) N
0 T () N
0 T (        innerloop.spc_innerloop\(e_lj, e_crf, dist6i, f, r2, r2i, ri\);) N
0 T () N
0 T (        ) S
(for) K
( \() p
(int) k
( ii = 0; ii < 9; ++ii\) {) p n
(570) # (          fx[ii] = f[ii] * x[ii];) N
0 T (          fy[ii] = f[ii] * y[ii];) N
0 T (          fz[ii] = f[ii] * z[ii];) N
0 T (        }) N
0 T () N
(575) # (        \(*force_j\)\(0\) -= fx[0] + fx[3] + fx[4];) N
0 T (        \(*force_j\)\(1\) -= fy[0] + fy[3] + fy[4];) N
0 T (        \(*force_j\)\(2\) -= fz[0] + fz[3] + fz[4];) N
0 T (        \(*\(force_j + 1\)\)\(0\) -= fx[1] + fx[5] + fx[7];) N
0 T (        \(*\(force_j + 1\)\)\(1\) -= fy[1] + fy[5] + fy[7];) N
(580) # (        \(*\(force_j + 1\)\)\(2\) -= fz[1] + fz[5] + fz[7];) N
0 T (        \(*\(force_j + 2\)\)\(0\) -= fx[2] + fx[6] + fx[8];) N
0 T (        \(*\(force_j + 2\)\)\(1\) -= fy[2] + fy[6] + fy[8];) N
0 T (        \(*\(force_j + 2\)\)\(2\) -= fz[2] + fz[6] + fz[8];) N
0 T () N
(585) # (        groupForce0\(0\) += fx[0] + fx[1] + fx[2];) N
0 T (        groupForce0\(1\) += fy[0] + fy[1] + fy[2];) N
0 T (        groupForce0\(2\) += fz[0] + fz[1] + fz[2];) N
0 T (        groupForce1\(0\) += fx[3] + fx[5] + fx[6];) N
0 T (        groupForce1\(1\) += fy[3] + fy[5] + fy[6];) N
(590) # (        groupForce1\(2\) += fz[3] + fz[5] + fz[6];) N
0 T (        groupForce2\(0\) += fx[4] + fx[7] + fx[8];) N
0 T (        groupForce2\(1\) += fy[4] + fy[7] + fy[8];) N
0 T (        groupForce2\(2\) += fz[4] + fz[7] + fz[8];) N
0 T (      }) N
(595) # () N
0 T (      storage.force\(i\) += groupForce0;) N
0 T (      storage.force\(i + 1\) += groupForce1;) N
0 T (      storage.force\(i + 2\) += groupForce2;) N
0 T (      ) N
(600) # (      ) S
(if) K
( \(k != 0\) {) p n
0 T (        ) S
(for) K
( \() p
(int) k
( a = 0; a < 3; ++a\) {) p n
0 T (          ) S
(for) K
( \() p
(int) k
( b = 0; b < 3; ++b\) {) p n
0 T (            ) S
(//storage.virial_tensor\(b, a\) += \(posI\(b\) + shift\(b\)\) * groupForce\(a) c n
0 T (\);) N
0 T () S
(            storage.virial_tensor\(b, a\) += shift\(b\) * \(groupForce0\(a\) + groupFor) p n
0 T (ce1\(a\) + groupForce2\(a\)\);) N
(605) # (          }) N
0 T (        }) N
0 T (      }) N
0 T () N
0 T (      storage.energies.lj_energy[egroup][egroup] += e_lj;) N
(610) # (      storage.energies.crf_energy[egroup][egroup] += e_crf;) N
0 T (    }) N
0 T (    ) N
0 T (    ) S
(for) K
( \() p
(unsigned) k
( ) p
(int) k
( ii = end; ii < size_i; ++ii\) {) p n
0 T (      ) S
(const) K
( math::Vec pos = conf.current\(\).pos\(ii\);) p n
(615) # (      ) S
(const) K
( math::Vec force = storage.force\(ii\);) p n
0 T (      ) S
(//std::cout << "XYZ\\t" << ii << std::setprecision\(9\)) c n
(nonbonded_outerloop.cc) (Page 9/40) (Dec 06, 18 14:53) title
border
/v 1 store
/x0 x v get 2.965278 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
0 T (      ) p
(//          << std::setw\(20\) << force\(0\) << std::setw\(20\) << force\(0\) << s) c n
0 T (td::setw\(20\) << force\(0\)) N
0 T () S
(      ) p
(//          << std::endl;) c n
0 T () S
(      ) p
(for) K
( \() p
(int) k
( a = 0; a < 3; ++a\) {) p n
(620) # (        ) S
(for) K
( \() p
(int) k
( b = 0; b < 3; ++b\) {) p n
0 T (          ) S
(//storage.virial_tensor\(b, a\) += \(posI\(b\) + shift\(b\)\) * groupForce\(a\);) c n
0 T () S
(          storage.virial_tensor\(b, a\) += pos\(b\) * force\(a\);) p n
0 T (        }) N
0 T (      }) N
(625) # (    }) N
0 T (    ) N
0 T (    ) N
0 T (  } ) S
(else) K
( ) p
(if) K
( \(sim.param\(\).force.special_loop == simulation::special_loop_spc_tabl) p n
0 T (e\) { ) S
(// special solvent loop) c n
0 T () S
(    ) p
(// solvent - solvent with tabulated spc innerloop...) c n
(630) # () N
0 T () S
(    ) p
(// only one energy group) c n
0 T () S
(    ) p
(const) K
( ) p
(int) k
( egroup = topo.atom_energy_group\(topo.num_solute_atoms\(\)\);) p n
0 T (    ) S
(if) K
( \(longrange\) {) p n
0 T (      ) S
(double) k
( e_lj = 0.0, e_crf = 0.0;) p n
(635) # (      ) S
(// here we call the longrange function that uses a smaller table) c n
0 T () S
(      ) p
(for) K
( \(; i < size_i; i += 3\) { ) p
(// use every third pairlist \(OW's\)) c n
0 T () N
0 T () S
(        ) p
(const) K
( math::Vec posI = conf.current\(\).pos\(i\);) p n
0 T (        ) S
(const) K
( math::Vec posI1 = conf.current\(\).pos\(i + 1\);) p n
(640) # (        ) S
(const) K
( math::Vec posI2 = conf.current\(\).pos\(i + 2\);) p n
0 T (        math::Vec groupForce0\(0.0\);) N
0 T (        math::Vec groupForce1\(0.0\);) N
0 T (        math::Vec groupForce2\(0.0\);) N
0 T (        ) S
(int) k
( k = 0;) p n
(645) # (        math::Vec shift = periodicity.shift\(k + 13\).pos;) N
0 T (        ) S
(double) k
( tx = shift\(0\), ty = shift\(1\), tz = shift\(2\);) p n
0 T () N
0 T (        ) S
(double) k
( r2[9], x[9], y[9], z[9], f[9], fx[9], fy[9], fz[9];) p n
0 T (        math::Vec r;) N
(650) # () N
0 T (        ) S
(for) K
( \(j_it = pairlist_solvent[i].begin\(\),) p n
0 T (            j_to = pairlist_solvent[i].end\(\);) N
0 T (            j_it != j_to;) N
0 T (            j_it += 3\) { ) S
(// use every third atom \(OW\) in pairlist i) c n
(655) # () N
0 T () S
(          DEBUG\(10, ") p
(\\tsolvent-solvent \(tabulated\) longrange spc_nonbonded_interaction: i ) str
(" << i << ") p
( j) str n
0 T ( ) S
(" << *j_it\);) p n
0 T () N
0 T (          ) S
(const) K
( ) p
(int) k
( kk = periodicity.nearest_image\(posI, conf.current\(\).pos\(*j_i) p n
0 T (t\), r\);) N
0 T () N
(660) # (          ) S
(if) K
( \(kk != k\) {) p n
0 T (            storage.force\(i\) += groupForce0;) N
0 T (            storage.force\(i + 1\) += groupForce1;) N
0 T (            storage.force\(i + 2\) += groupForce2;) N
0 T (            ) S
(if) K
( \(k != 0\) {) p n
(665) # (              ) S
(for) K
( \() p
(int) k
( a = 0; a < 3; ++a\) {) p n
0 T (                ) S
(for) K
( \() p
(int) k
( b = 0; b < 3; ++b\) {) p n
0 T (                  ) S
(//storage.virial_tensor\(b, a\) += \(posI\(b\) + shift\(b\)\) * groupF) c n
0 T (orce\(a\);) N
0 T () S
(                  storage.virial_tensor\(b, a\) += shift\(b\) * \(groupForce0\(a\) + gr) p n
0 T (oupForce1\(a\) + groupForce2\(a\)\);) N
0 T (                }) N
(670) # (              }) N
0 T (            }) N
0 T (            groupForce0 = 0.;) N
0 T (            groupForce1 = 0.;) N
0 T (            groupForce2 = 0.;) N
(675) # (            k = kk;) N
0 T (            shift = periodicity.shift\(k + 13\).pos;) N
0 T (            tx = shift\(0\);) N
0 T (            ty = shift\(1\);) N
0 T (            tz = shift\(2\);) N
(680) # (          }) N
0 T () N
0 T (          math::Vec ) S
(const) K
( * ) p
(const) K
( pos_j = &conf.current\(\).pos\(*j_it\);) p n
0 T (          math::Vec * ) S
(const) K
( force_j = &storage.force\(*j_it\);) p n
(nonbonded_outerloop.cc) (Page 10/40) (Dec 06, 18 14:53) title
border
grestore
(Printed by Patrick Bleiziffer) rhead
(nonbonded_outerloop.cc) (5/20) (Thursday December 06, 2018) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (11-12) 6
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 2.965278 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
0 T () p n
(685) # (          x[0] = r\(0\);) N
0 T (          y[0] = r\(1\);) N
0 T (          z[0] = r\(2\);) N
0 T () N
0 T (          x[1] = posI\(0\) - \(*\(pos_j + 1\)\)\(0\) + tx;) N
(690) # (          y[1] = posI\(1\) - \(*\(pos_j + 1\)\)\(1\) + ty;) N
0 T (          z[1] = posI\(2\) - \(*\(pos_j + 1\)\)\(2\) + tz;) N
0 T () N
0 T (          x[2] = posI\(0\) - \(*\(pos_j + 2\)\)\(0\) + tx;) N
0 T (          y[2] = posI\(1\) - \(*\(pos_j + 2\)\)\(1\) + ty;) N
(695) # (          z[2] = posI\(2\) - \(*\(pos_j + 2\)\)\(2\) + tz;) N
0 T () N
0 T (          x[3] = posI1\(0\) - \(*\(pos_j\)\)\(0\) + tx;) N
0 T (          y[3] = posI1\(1\) - \(*\(pos_j\)\)\(1\) + ty;) N
0 T (          z[3] = posI1\(2\) - \(*\(pos_j\)\)\(2\) + tz;) N
(700) # () N
0 T (          x[4] = posI2\(0\) - \(*\(pos_j\)\)\(0\) + tx;) N
0 T (          y[4] = posI2\(1\) - \(*\(pos_j\)\)\(1\) + ty;) N
0 T (          z[4] = posI2\(2\) - \(*\(pos_j\)\)\(2\) + tz;) N
0 T () N
(705) # (          x[5] = posI1\(0\) - \(*\(pos_j + 1\)\)\(0\) + tx;) N
0 T (          y[5] = posI1\(1\) - \(*\(pos_j + 1\)\)\(1\) + ty;) N
0 T (          z[5] = posI1\(2\) - \(*\(pos_j + 1\)\)\(2\) + tz;) N
0 T () N
0 T (          x[6] = posI1\(0\) - \(*\(pos_j + 2\)\)\(0\) + tx;) N
(710) # (          y[6] = posI1\(1\) - \(*\(pos_j + 2\)\)\(1\) + ty;) N
0 T (          z[6] = posI1\(2\) - \(*\(pos_j + 2\)\)\(2\) + tz;) N
0 T () N
0 T (          x[7] = posI2\(0\) - \(*\(pos_j + 1\)\)\(0\) + tx;) N
0 T (          y[7] = posI2\(1\) - \(*\(pos_j + 1\)\)\(1\) + ty;) N
(715) # (          z[7] = posI2\(2\) - \(*\(pos_j + 1\)\)\(2\) + tz;) N
0 T () N
0 T (          x[8] = posI2\(0\) - \(*\(pos_j + 2\)\)\(0\) + tx;) N
0 T (          y[8] = posI2\(1\) - \(*\(pos_j + 2\)\)\(1\) + ty;) N
0 T (          z[8] = posI2\(2\) - \(*\(pos_j + 2\)\)\(2\) + tz;) N
(720) # () N
0 T (          ) S
(for) K
( \() p
(int) k
( ii = 0; ii < 9; ++ii\) {) p n
0 T (            r2[ii] = x[ii] * x[ii] + y[ii] * y[ii] + z[ii] * z[ii];) N
0 T (          }) N
0 T () N
(725) # (          innerloop.longrange_spc_table_innerloop\(e_lj, e_crf, f, r2\);) N
0 T () N
0 T (          ) S
(for) K
( \() p
(int) k
( ii = 0; ii < 9; ++ii\) {) p n
0 T (            fx[ii] = f[ii] * x[ii];) N
0 T (            fy[ii] = f[ii] * y[ii];) N
(730) # (            fz[ii] = f[ii] * z[ii];) N
0 T (          }) N
0 T () N
0 T (          \(*force_j\)\(0\) -= fx[0] + fx[3] + fx[4];) N
0 T (          \(*force_j\)\(1\) -= fy[0] + fy[3] + fy[4];) N
(735) # (          \(*force_j\)\(2\) -= fz[0] + fz[3] + fz[4];) N
0 T (          \(*\(force_j + 1\)\)\(0\) -= fx[1] + fx[5] + fx[7];) N
0 T (          \(*\(force_j + 1\)\)\(1\) -= fy[1] + fy[5] + fy[7];) N
0 T (          \(*\(force_j + 1\)\)\(2\) -= fz[1] + fz[5] + fz[7];) N
0 T (          \(*\(force_j + 2\)\)\(0\) -= fx[2] + fx[6] + fx[8];) N
(740) # (          \(*\(force_j + 2\)\)\(1\) -= fy[2] + fy[6] + fy[8];) N
0 T (          \(*\(force_j + 2\)\)\(2\) -= fz[2] + fz[6] + fz[8];) N
0 T () N
0 T (          groupForce0\(0\) += fx[0] + fx[1] + fx[2];) N
0 T (          groupForce0\(1\) += fy[0] + fy[1] + fy[2];) N
(745) # (          groupForce0\(2\) += fz[0] + fz[1] + fz[2];) N
0 T (          groupForce1\(0\) += fx[3] + fx[5] + fx[6];) N
0 T (          groupForce1\(1\) += fy[3] + fy[5] + fy[6];) N
0 T (          groupForce1\(2\) += fz[3] + fz[5] + fz[6];) N
0 T (          groupForce2\(0\) += fx[4] + fx[7] + fx[8];) N
(750) # (          groupForce2\(1\) += fy[4] + fy[7] + fy[8];) N
0 T (          groupForce2\(2\) += fz[4] + fz[7] + fz[8];) N
0 T (        }) N
0 T () N
0 T (        storage.force\(i\) += groupForce0;) N
(755) # (        storage.force\(i + 1\) += groupForce1;) N
0 T (        storage.force\(i + 2\) += groupForce2;) N
(nonbonded_outerloop.cc) (Page 11/40) (Dec 06, 18 14:53) title
border
/v 1 store
/x0 x v get 2.965278 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
0 T (        ) p
(if) K
( \(k != 0\) {) p n
0 T (          ) S
(for) K
( \() p
(int) k
( a = 0; a < 3; ++a\) {) p n
0 T (            ) S
(for) K
( \() p
(int) k
( b = 0; b < 3; ++b\) {) p n
(760) # (              ) S
(//storage.virial_tensor\(b, a\) += \(posI\(b\) + shift\(b\)\) * groupForce) c n
0 T (\(a\);) N
0 T () S
(              storage.virial_tensor\(b, a\) += shift\(b\) * \(groupForce0\(a\) + groupF) p n
0 T (orce1\(a\) + groupForce2\(a\)\);) N
0 T (            }) N
0 T (          }) N
0 T (        }) N
(765) # (      }) N
0 T () N
0 T (    ) S
(for) K
( \() p
(unsigned) k
( ) p
(int) k
( ii = topo.num_solute_atoms\(\); ii < size_i; ++ii\) {) p n
0 T (      ) S
(const) K
( math::Vec pos = conf.current\(\).pos\(ii\);) p n
0 T (      ) S
(const) K
( math::Vec force = storage.force\(ii\);) p n
(770) # (      ) S
(for) K
( \() p
(int) k
( a = 0; a < 3; ++a\) {) p n
0 T (        ) S
(for) K
( \() p
(int) k
( b = 0; b < 3; ++b\) {) p n
0 T (          ) S
(//innerloop.spc_innerloop\(topo, conf, i, *j_it, storage, periodicity\);) c n
0 T () S
(          storage.virial_tensor\(b, a\) += pos\(b\) * force\(a\);) p n
0 T (        }) N
(775) # (      }) N
0 T (    }) N
0 T () N
0 T (      storage.energies.lj_energy[egroup][egroup] += e_lj;) N
0 T (      storage.energies.crf_energy[egroup][egroup] += e_crf;) N
(780) # (    } ) S
(else) K
( { ) p
(// shortrange) c n
0 T () S
(      ) p
(double) k
( e_lj = 0.0, e_crf = 0.0;) p n
0 T (      ) S
(for) K
( \(; i < size_i; i += 3\) { ) p
(// use every third pairlist \(OW's\)) c n
0 T () N
0 T () S
(        ) p
(const) K
( math::Vec posI = conf.current\(\).pos\(i\);) p n
(785) # (        ) S
(const) K
( math::Vec posI1 = conf.current\(\).pos\(i + 1\);) p n
0 T (        ) S
(const) K
( math::Vec posI2 = conf.current\(\).pos\(i + 2\);) p n
0 T (        math::Vec groupForce0\(0.0\);) N
0 T (        math::Vec groupForce1\(0.0\);) N
0 T (        math::Vec groupForce2\(0.0\);) N
(790) # (        ) S
(int) k
( k = 0;) p n
0 T (        math::Vec shift = periodicity.shift\(k + 13\).pos;) N
0 T (        ) S
(double) k
( tx = shift\(0\), ty = shift\(1\), tz = shift\(2\);) p n
0 T () N
0 T (        ) S
(double) k
( r2[9], x[9], y[9], z[9], f[9], fx[9], fy[9], fz[9];) p n
(795) # (        math::Vec r;) N
0 T () N
0 T (        ) S
(for) K
( \(j_it = pairlist_solvent[i].begin\(\),) p n
0 T (                j_to = pairlist_solvent[i].end\(\);) N
0 T (                j_it != j_to;) N
(800) # (                j_it += 3\) { ) S
(// use every third atom \(OW\) in pairlist i) c n
0 T () N
0 T () S
(          DEBUG\(10, ") p
(\\tsolvent-solvent \(tabulated\) shortrange spc_nonbonded_interaction: i ) str
(" << i << ") p
( ) str n
0 T (j ) S
(" << *j_it\);) p n
0 T () N
0 T (          ) S
(const) K
( ) p
(int) k
( kk = periodicity.nearest_image\(posI, conf.current\(\).pos\(*j_i) p n
0 T (t\), r\);) N
(805) # () N
0 T (          ) S
(if) K
( \(kk != k\) {) p n
0 T (            storage.force\(i\) += groupForce0;) N
0 T (            storage.force\(i + 1\) += groupForce1;) N
0 T (            storage.force\(i + 2\) += groupForce2;) N
(810) # (            ) S
(if) K
( \(k != 0\) {) p n
0 T (              ) S
(for) K
( \() p
(int) k
( a = 0; a < 3; ++a\) {) p n
0 T (                ) S
(for) K
( \() p
(int) k
( b = 0; b < 3; ++b\) {) p n
0 T (                  ) S
(//storage.virial_tensor\(b, a\) += \(posI\(b\) + shift\(b\)\) * groupF) c n
0 T (orce\(a\);) N
0 T () S
(                  storage.virial_tensor\(b, a\) += shift\(b\) * \(groupForce0\(a\) + gr) p n
0 T (oupForce1\(a\) + groupForce2\(a\)\);) N
(815) # (                }) N
0 T (              }) N
0 T (            }) N
0 T (            groupForce0 = 0.;) N
0 T (            groupForce1 = 0.;) N
(820) # (            groupForce2 = 0.;) N
0 T (            k = kk;) N
0 T (            shift = periodicity.shift\(k + 13\).pos;) N
0 T (            tx = shift\(0\);) N
(nonbonded_outerloop.cc) (Page 12/40) (Dec 06, 18 14:53) title
border
grestore
(Printed by Patrick Bleiziffer) rhead
(nonbonded_outerloop.cc) (6/20) (Thursday December 06, 2018) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (13-14) 7
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 2.965278 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
0 T (            ty = shift\(1\);) p n
(825) # (            tz = shift\(2\);) N
0 T (          }) N
0 T () N
0 T (          math::Vec ) S
(const) K
( * ) p
(const) K
( pos_j = &conf.current\(\).pos\(*j_it\);) p n
0 T (          math::Vec * ) S
(const) K
( force_j = &storage.force\(*j_it\);) p n
(830) # () N
0 T (          x[0] = r\(0\);) N
0 T (          y[0] = r\(1\);) N
0 T (          z[0] = r\(2\);) N
0 T () N
(835) # (          x[1] = posI\(0\) - \(*\(pos_j + 1\)\)\(0\) + tx;) N
0 T (          y[1] = posI\(1\) - \(*\(pos_j + 1\)\)\(1\) + ty;) N
0 T (          z[1] = posI\(2\) - \(*\(pos_j + 1\)\)\(2\) + tz;) N
0 T () N
0 T (          x[2] = posI\(0\) - \(*\(pos_j + 2\)\)\(0\) + tx;) N
(840) # (          y[2] = posI\(1\) - \(*\(pos_j + 2\)\)\(1\) + ty;) N
0 T (          z[2] = posI\(2\) - \(*\(pos_j + 2\)\)\(2\) + tz;) N
0 T () N
0 T (          x[3] = posI1\(0\) - \(*\(pos_j\)\)\(0\) + tx;) N
0 T (          y[3] = posI1\(1\) - \(*\(pos_j\)\)\(1\) + ty;) N
(845) # (          z[3] = posI1\(2\) - \(*\(pos_j\)\)\(2\) + tz;) N
0 T () N
0 T (          x[4] = posI2\(0\) - \(*\(pos_j\)\)\(0\) + tx;) N
0 T (          y[4] = posI2\(1\) - \(*\(pos_j\)\)\(1\) + ty;) N
0 T (          z[4] = posI2\(2\) - \(*\(pos_j\)\)\(2\) + tz;) N
(850) # () N
0 T (          x[5] = posI1\(0\) - \(*\(pos_j + 1\)\)\(0\) + tx;) N
0 T (          y[5] = posI1\(1\) - \(*\(pos_j + 1\)\)\(1\) + ty;) N
0 T (          z[5] = posI1\(2\) - \(*\(pos_j + 1\)\)\(2\) + tz;) N
0 T () N
(855) # (          x[6] = posI1\(0\) - \(*\(pos_j + 2\)\)\(0\) + tx;) N
0 T (          y[6] = posI1\(1\) - \(*\(pos_j + 2\)\)\(1\) + ty;) N
0 T (          z[6] = posI1\(2\) - \(*\(pos_j + 2\)\)\(2\) + tz;) N
0 T () N
0 T (          x[7] = posI2\(0\) - \(*\(pos_j + 1\)\)\(0\) + tx;) N
(860) # (          y[7] = posI2\(1\) - \(*\(pos_j + 1\)\)\(1\) + ty;) N
0 T (          z[7] = posI2\(2\) - \(*\(pos_j + 1\)\)\(2\) + tz;) N
0 T () N
0 T (          x[8] = posI2\(0\) - \(*\(pos_j + 2\)\)\(0\) + tx;) N
0 T (          y[8] = posI2\(1\) - \(*\(pos_j + 2\)\)\(1\) + ty;) N
(865) # (          z[8] = posI2\(2\) - \(*\(pos_j + 2\)\)\(2\) + tz;) N
0 T () N
0 T (          ) S
(for) K
( \() p
(int) k
( ii = 0; ii < 9; ++ii\) {) p n
0 T (            r2[ii] = x[ii] * x[ii] + y[ii] * y[ii] + z[ii] * z[ii];) N
0 T (          }) N
(870) # () N
0 T (          innerloop.shortrange_spc_table_innerloop\(e_lj, e_crf, f, r2\);) N
0 T () N
0 T (          ) S
(for) K
( \() p
(int) k
( ii = 0; ii < 9; ++ii\) {) p n
0 T (            fx[ii] = f[ii] * x[ii];) N
(875) # (            fy[ii] = f[ii] * y[ii];) N
0 T (            fz[ii] = f[ii] * z[ii];) N
0 T (          }) N
0 T () N
0 T (          \(*force_j\)\(0\) -= fx[0] + fx[3] + fx[4];) N
(880) # (          \(*force_j\)\(1\) -= fy[0] + fy[3] + fy[4];) N
0 T (          \(*force_j\)\(2\) -= fz[0] + fz[3] + fz[4];) N
0 T (          \(*\(force_j + 1\)\)\(0\) -= fx[1] + fx[5] + fx[7];) N
0 T (          \(*\(force_j + 1\)\)\(1\) -= fy[1] + fy[5] + fy[7];) N
0 T (          \(*\(force_j + 1\)\)\(2\) -= fz[1] + fz[5] + fz[7];) N
(885) # (          \(*\(force_j + 2\)\)\(0\) -= fx[2] + fx[6] + fx[8];) N
0 T (          \(*\(force_j + 2\)\)\(1\) -= fy[2] + fy[6] + fy[8];) N
0 T (          \(*\(force_j + 2\)\)\(2\) -= fz[2] + fz[6] + fz[8];) N
0 T () N
0 T (          groupForce0\(0\) += fx[0] + fx[1] + fx[2];) N
(890) # (          groupForce0\(1\) += fy[0] + fy[1] + fy[2];) N
0 T (          groupForce0\(2\) += fz[0] + fz[1] + fz[2];) N
0 T (          groupForce1\(0\) += fx[3] + fx[5] + fx[6];) N
0 T (          groupForce1\(1\) += fy[3] + fy[5] + fy[6];) N
0 T (          groupForce1\(2\) += fz[3] + fz[5] + fz[6];) N
(895) # (          groupForce2\(0\) += fx[4] + fx[7] + fx[8];) N
0 T (          groupForce2\(1\) += fy[4] + fy[7] + fy[8];) N
(nonbonded_outerloop.cc) (Page 13/40) (Dec 06, 18 14:53) title
border
/v 1 store
/x0 x v get 2.965278 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
0 T (          groupForce2\(2\) += fz[4] + fz[7] + fz[8];) p n
0 T (        }) N
0 T () N
(900) # (        storage.force\(i\) += groupForce0;) N
0 T (        storage.force\(i + 1\) += groupForce1;) N
0 T (        storage.force\(i + 2\) += groupForce2;) N
0 T (        ) S
(if) K
( \(k != 0\) {) p n
0 T (          ) S
(for) K
( \() p
(int) k
( a = 0; a < 3; ++a\) {) p n
(905) # (            ) S
(for) K
( \() p
(int) k
( b = 0; b < 3; ++b\) {) p n
0 T (              ) S
(//storage.virial_tensor\(b, a\) += \(posI\(b\) + shift\(b\)\) * groupForce) c n
0 T (\(a\);) N
0 T () S
(              storage.virial_tensor\(b, a\) += shift\(b\) * \(groupForce0\(a\) + groupF) p n
0 T (orce1\(a\) + groupForce2\(a\)\);) N
0 T (            }) N
0 T (          }) N
(910) # (        }) N
0 T (      }) N
0 T () N
0 T (    ) S
(for) K
( \() p
(unsigned) k
( ) p
(int) k
( ii = topo.num_solute_atoms\(\); ii < size_i; ++ii\) {) p n
0 T (      ) S
(const) K
( math::Vec pos = conf.current\(\).pos\(ii\);) p n
(915) # (      ) S
(const) K
( math::Vec force = storage.force\(ii\);) p n
0 T (      ) S
(for) K
( \() p
(int) k
( a = 0; a < 3; ++a\) {) p n
0 T (        ) S
(for) K
( \() p
(int) k
( b = 0; b < 3; ++b\) {) p n
0 T (          ) S
(//innerloop.spc_innerloop\(topo, conf, i, *j_it, storage, periodicity\);) c n
0 T () S
(          storage.virial_tensor\(b, a\) += pos\(b\) * force\(a\);) p n
(920) # (        }) N
0 T (      }) N
0 T (    }) N
0 T () N
0 T (      storage.energies.lj_energy[egroup][egroup]  += e_lj;) N
(925) # (      storage.energies.crf_energy[egroup][egroup] += e_crf;) N
0 T (    }) N
0 T (  } ) S
(else) K
( ) p
(if) K
( \(sim.param\(\).force.special_loop == simulation::special_loop_generic\)) p n
0 T ( {) N
0 T (    ) S
(const) K
( ) p
(unsigned) k
( ) p
(int) k
( num_solvent_atoms = topo.solvent\(0\).num_atoms\(\);) p n
0 T (    ) S
(// prepare parameters) c n
(930) # () S
(    ) p
(const) K
( ) p
(unsigned) k
( ) p
(int) k
( num_param = num_solvent_atoms * num_solvent_atoms;) p n
0 T (    ) S
(typename) k
( interaction::Nonbonded_Innerloop<interaction::Interaction_Spec<math) p n
0 T (::rectangular, simulation::lj_crf_func> >::solvent_pair_parameter pair_parameter) N
0 T ([num_param];) N
0 T () N
0 T (    ) S
(unsigned) k
( ) p
(int) k
( param = 0;) p n
0 T (    ) S
(for) K
( \() p
(unsigned) k
( ) p
(int) k
( atom_i = 0; atom_i < num_solvent_atoms; ++atom_i\) {) p n
(935) # (      ) S
(for) K
( \() p
(unsigned) k
( ) p
(int) k
( atom_j = 0; atom_j < num_solvent_atoms; ++atom_j, ++para) p n
0 T (m\) {) N
0 T (        assert\(param < num_param\);) N
0 T (        DEBUG\(10, ") S
(\\tsolvent pair parameter: ) str
(" << param\);) p n
0 T () N
0 T (        ) S
(const) K
( lj_parameter_struct & lj =) p n
(940) # (                innerloop.param\(\)->lj_parameter\(topo.solvent\(0\).atom\(atom_i\).iac) N
0 T (, topo.solvent\(0\).atom\(atom_j\).iac\);) N
0 T (        pair_parameter[param].c12 = lj.c12;) N
0 T (        pair_parameter[param].c6 = lj.c6;) N
0 T () N
0 T (        pair_parameter[param].q = math::four_pi_eps_i *) N
(945) # (                topo.solvent\(0\).atom\(atom_i\).charge *) N
0 T (                topo.solvent\(0\).atom\(atom_j\).charge;) N
0 T () N
0 T (        DEBUG\(10, ") S
(\\t\\tc12: ) str
(" << pair_parameter[param].c12 << ") p
( c6: ) str
(" <<) p n
0 T (                pair_parameter[param].c6 << ") S
( q: ) str
(" << pair_parameter[param].q\);) p n
(950) # (      }) N
0 T (    }) N
0 T () N
0 T (    math::Vec r;) N
0 T (    ) N
(955) # (    ) S
(const) K
( ) p
(double) k
( crf_2cut3i = innerloop.crf_2cut3i\(0\);) p n
0 T (    ) S
(const) K
( ) p
(double) k
( crf_cut3i  = crf_2cut3i * 2.;) p n
0 T (    ) S
(const) K
( ) p
(double) k
( crf_cut    = innerloop.crf_cut\(0\);) p n
0 T (  ) N
0 T (    ) S
(// only one energy group) c n
(960) # () S
(    ) p
(const) K
( ) p
(int) k
( egroup = topo.atom_energy_group\(topo.num_solute_atoms\(\)\);) p n
0 T (    ) S
(double) k
( e_lj = 0.0, e_crf = 0.0;) p n
0 T (    ) S
(// use num_solvent_atoms-th atom \(first of solvent molecule i\)) c n
(nonbonded_outerloop.cc) (Page 14/40) (Dec 06, 18 14:53) title
border
grestore
(Printed by Patrick Bleiziffer) rhead
(nonbonded_outerloop.cc) (7/20) (Thursday December 06, 2018) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (15-16) 8
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 2.965278 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
0 T (    ) p
(for) K
( \(; i < size_i; i += num_solvent_atoms\) {) p n
0 T (      math::Vec ) S
(const) K
( * ) p
(const) K
( pos_i = &conf.current\(\).pos\(i\);) p n
(965) # (      math::Vec * ) S
(const) K
( force_i = &storage.force\(i\);) p n
0 T (      ) S
(int) k
( k = 0;) p n
0 T (      std::vector<math::Vec> groupForce\(num_solvent_atoms, math::Vec\(0.0\)\);) N
0 T (      math::Vec totalForce;) N
0 T (      math::Vec shift = periodicity.shift\(k+13\).pos;) N
(970) # (      ) S
(double) k
( tx = shift\(0\), ty = shift\(1\), tz = shift\(2\);) p n
0 T (      ) N
0 T (      ) S
(for) K
( \(j_it = pairlist_solvent[i].begin\(\),) p n
0 T (              j_to = pairlist_solvent[i].end\(\);) N
0 T (              j_it != j_to;) N
(975) # (              j_it += num_solvent_atoms\) { ) S
(// use num_solvent_atoms-th atom \(fir) c n
0 T (st of solvent molecule j\)) N
0 T () N
0 T () S
(        DEBUG\(10, ") p
(\\tsolvent_nonbonded_interaction \(special_loop_generic\): i ) str
(" << i << ") p
( j ) str
(" << *j_i) p n
0 T (t\);) N
0 T () N
0 T (        ) S
(const) K
( ) p
(int) k
( kk = periodicity.nearest_image\(*pos_i, conf.current\(\).pos\(*j_i) p n
0 T (t\), r\);) N
(980) # (        ) N
0 T (        ) S
(if) K
( \(kk != k\) {) p n
0 T () S 8 T (  totalForce = 0.;) N
0 T (          ) S
(for) K
(\() p
(unsigned) k
( ) p
(int) k
( atom_i = 0; atom_i < num_solvent_atoms; ++atom_i\) {) p n
0 T (            \(*\(force_i+atom_i\)\) += groupForce[atom_i];) N
(985) # (            ) S
(if) K
( \(k != 0\) {) p n
0 T () S 8 T (      totalForce += groupForce[atom_i];) N
0 T (            }            ) N
0 T (            groupForce[atom_i] = 0.0;) N
0 T (          }) N
(990) # () S 8 T (  ) S
(if) K
( \(k != 0\) {) p n
0 T (            ) S
(const) K
( math::Vec shift = periodicity.shift\(k+13\).pos;) p n
0 T (            ) S
(for) K
( \() p
(int) k
( a = 0; a < 3; ++a\) {) p n
0 T (              ) S
(for) K
( \() p
(int) k
( b = 0; b < 3; ++b\) {) p n
0 T (                ) S
(//storage.virial_tensor\(b, a\) += \(posI\(b\) + shift\(b\)\) * groupFor) c n
0 T (ce\(a\);) N
(995) # () S
(                storage.virial_tensor\(b, a\) += shift\(b\) * totalForce\(a\);) p n
0 T (              }) N
0 T (            }) N
0 T () S 8 T (  }) N
0 T (          k = kk;) N
(1000) # (          shift = periodicity.shift\(k + 13\).pos;) N
0 T (          tx = shift\(0\);) N
0 T (          ty = shift\(1\);) N
0 T (          tz = shift\(2\);) N
0 T (        }) N
(1005) # (        ) N
0 T (        math::Vec ) S
(const) K
( * ) p
(const) K
( pos_j = &conf.current\(\).pos\(*j_it\);) p n
0 T (        math::Vec * ) S
(const) K
( force_j = &storage.force\(*j_it\);) p n
0 T (        ) N
0 T (        ) S
(for) K
(\() p
(unsigned) k
( ) p
(int) k
( param = 0, atom_i = 0; atom_i < num_solvent_atoms; ++at) p n
0 T (om_i\) {) N
(1010) # (          ) S
(const) K
( ) p
(double) k
( xi = \(*\(pos_i+atom_i\)\)\(0\) + tx;) p n
0 T (          ) S
(const) K
( ) p
(double) k
( yi = \(*\(pos_i+atom_i\)\)\(1\) + ty;) p n
0 T (          ) S
(const) K
( ) p
(double) k
( zi = \(*\(pos_i+atom_i\)\)\(2\) + tz;) p n
0 T (          ) S
(for) K
(\() p
(unsigned) k
( ) p
(int) k
( atom_j = 0; atom_j < num_solvent_atoms; ++atom_j, ++p) p n
0 T (aram\) {) N
0 T (            DEBUG\(15, ") S
(\\tatoms: i: ) str
(" << atom_i << ") p
( j: ) str
(" << atom_j\);) p n
(1015) # (            ) S
(const) K
( ) p
(double) k
( x = xi - \(*\(pos_j+atom_j\)\)\(0\);) p n
0 T (            ) S
(const) K
( ) p
(double) k
( y = yi - \(*\(pos_j+atom_j\)\)\(1\);) p n
0 T (            ) S
(const) K
( ) p
(double) k
( z = zi - \(*\(pos_j+atom_j\)\)\(2\);) p n
0 T () N
0 T (            ) S
(const) K
( ) p
(double) k
( r2 = x * x + y * y + z * z;) p n
(1020) # (            DEBUG\(15, ") S
(\\tr2: ) str
(" << r2\);) p n
0 T (            assert\(r2 != 0.0\);) N
0 T (            ) S
(const) K
( ) p
(double) k
( r2i = 1.0 / r2;) p n
0 T (            ) S
(const) K
( ) p
(double) k
( ri = sqrt\(r2i\);) p n
0 T (            ) S
(const) K
( ) p
(double) k
( dist6i = r2i * r2i * r2i;) p n
(1025) # (            ) S
(const) K
( ) p
(double) k
( dist6i_c12 = pair_parameter[param].c12 * dist6i;) p n
0 T () N
0 T (            e_lj += \(dist6i_c12 - pair_parameter[param].c6\) * dist6i;) N
0 T (            e_crf += pair_parameter[param].q * \(ri - crf_2cut3i * r2 - crf_cut\);) N
0 T () N
(nonbonded_outerloop.cc) (Page 15/40) (Dec 06, 18 14:53) title
border
/v 1 store
/x0 x v get 2.965278 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(1030) # (            ) p
(const) K
( ) p
(double) k
( f = \(dist6i_c12 + dist6i_c12 - pair_parameter[param].c6) p n
0 T (\) * 6.0 ) N
0 T (                    * dist6i * r2i + pair_parameter[param].q * \(ri * r2i + crf_c) N
0 T (ut3i\);) N
0 T () N
0 T (            ) S
(const) K
( ) p
(double) k
( fx = f * x;) p n
0 T (            ) S
(const) K
( ) p
(double) k
( fy = f * y;) p n
(1035) # (            ) S
(const) K
( ) p
(double) k
( fz = f * z;) p n
0 T () N
0 T (            ) S
(//\(*\(force_i+atom_i\)\)\(0\) += fx;) c n
0 T () S
(            groupForce[atom_i]\(0\) += fx;) p n
0 T (            \(*\(force_j+atom_j\)\)\(0\) -= fx;) N
(1040) # (            ) S
(//\(*\(force_i+atom_i\)\)\(1\) += fy;) c n
0 T () S
(            groupForce[atom_i]\(1\) += fy;) p n
0 T (            \(*\(force_j+atom_j\)\)\(1\) -= fy;) N
0 T (            ) S
(//\(*\(force_i+atom_i\)\)\(2\) += fz;) c n
0 T () S
(            groupForce[atom_i]\(2\) += fz;) p n
(1045) # (            \(*\(force_j+atom_j\)\)\(2\) -= fz;) N
0 T (          }) N
0 T (        ) S
(// innerloop.solvent_innerloop\(topo, pair_parameter, conf, num_solvent_a) c n
0 T (toms, i, *j_it, storage, periodicity\);) N
0 T () S
(        }) p n
0 T (      }) N
(1050) # (        ) N
0 T (      totalForce = 0.;) N
0 T (      ) S
(for) K
(\() p
(unsigned) k
( ) p
(int) k
( atom_i = 0; atom_i < num_solvent_atoms; ++atom_i\) {) p n
0 T (        \(*\(force_i+atom_i\)\) += groupForce[atom_i];) N
0 T (        ) S
(if) K
( \(k != 0\) {) p n
(1055) # () S 8 T (  totalForce += groupForce[atom_i];) N
0 T (        }) N
0 T (      }) N
0 T (        ) N
0 T (      ) S
(if) K
( \(k != 0\) {) p n
(1060) # (        ) S
(const) K
( math::Vec shift = periodicity.shift\(k+13\).pos;) p n
0 T (        ) S
(for) K
( \() p
(int) k
( a = 0; a < 3; ++a\) {) p n
0 T (          ) S
(for) K
( \() p
(int) k
( b = 0; b < 3; ++b\) {) p n
0 T (            ) S
(//storage.virial_tensor\(b, a\) += \(posI\(b\) + shift\(b\)\) * groupForce\(a) c n
0 T (\);) N
0 T () S
(            storage.virial_tensor\(b, a\) += shift\(b\) * totalForce\(a\);) p n
(1065) # (          }) N
0 T (        }) N
0 T (      }   ) N
0 T (    }) N
0 T (    ) N
(1070) # (    storage.energies.lj_energy[egroup][egroup] += e_lj;) N
0 T (    storage.energies.crf_energy[egroup][egroup] += e_crf;) N
0 T (    ) N
0 T (    ) N
0 T (    ) S
(for) K
( \() p
(unsigned) k
( ) p
(int) k
( ii = end; ii < size_i; ++ii\) {) p n
(1075) # (      ) S
(const) K
( math::Vec pos = conf.current\(\).pos\(ii\);) p n
0 T (      ) S
(const) K
( math::Vec force = storage.force\(ii\);) p n
0 T (      ) S
(//std::cout << "XYZ\\t" << ii << std::setprecision\(9\)) c n
0 T () S
(      ) p
(//          << std::setw\(20\) << force\(0\) << std::setw\(20\) << force\(0\) << s) c n
0 T (td::setw\(20\) << force\(0\)) N
0 T () S
(      ) p
(//          << std::endl;) c n
(1080) # () S
(      ) p
(for) K
( \() p
(int) k
( a = 0; a < 3; ++a\) {) p n
0 T (        ) S
(for) K
( \() p
(int) k
( b = 0; b < 3; ++b\) {) p n
0 T (          ) S
(//storage.virial_tensor\(b, a\) += \(posI\(b\) + shift\(b\)\) * groupForce\(a\);) c n
0 T () S
(          storage.virial_tensor\(b, a\) += pos\(b\) * force\(a\);) p n
0 T (        }) N
(1085) # (      }) N
0 T (    }) N
0 T (    ) N
0 T (    ) N
0 T (  } ) S
(else) K
( { ) p
(// normal solvent loop) c n
(1090) # () S
(    ) p
(for) K
( \(; i < size_i; ++i\) {) p n
0 T (      ) S
(const) K
( math::Vec posI = conf.current\(\).pos\(i\);) p n
0 T (      ) S
(const) K
( ) p
(unsigned) k
( ) p
(int) k
( eg_i = topo.atom_energy_group\(i\);) p n
0 T (      math::Vec groupForce\(0.0\);) N
0 T (      ) S
(int) k
( k = 0;) p n
(1095) # (      ) S
(for) K
( \(j_it = pairlist_solvent[i].begin\(\),) p n
0 T (              j_to = pairlist_solvent[i].end\(\);) N
0 T (              j_it != j_to;) N
(nonbonded_outerloop.cc) (Page 16/40) (Dec 06, 18 14:53) title
border
grestore
(Printed by Patrick Bleiziffer) rhead
(nonbonded_outerloop.cc) (8/20) (Thursday December 06, 2018) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (17-18) 9
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 2.965278 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
0 T (              ++j_it\) {) p n
0 T () N
(1100) # (        DEBUG\(10, ") S
(\\tsolvent_nonbonded_interaction \(normal solvent loop\): i ) str
(" << i << ") p
( j ) str
(" << *j_it) p n
0 T (\);) N
0 T (            ) N
0 T (        math::Vec r;) N
0 T (        ) S
(const) K
( ) p
(int) k
( kk = periodicity.nearest_image\(posI, conf.current\(\).pos\(*j_it\)) p n
0 T (, r\);) N
0 T () N
(1105) # (        ) S
(if) K
( \(kk != k\) {) p n
0 T (          storage.force\(i\) += groupForce;) N
0 T (          ) S
(if) K
( \(k != 0\) {) p n
0 T (            ) S
(const) K
( math::Vec shift = periodicity.shift\(k+13\).pos;) p n
0 T (            ) S
(for) K
( \() p
(int) k
( a = 0; a < 3; ++a\) {) p n
(1110) # (              ) S
(for) K
( \() p
(int) k
( b = 0; b < 3; ++b\) {) p n
0 T (                ) S
(//storage.virial_tensor\(b, a\) += \(posI\(b\) + shift\(b\)\) * groupFor) c n
0 T (ce\(a\);) N
0 T () S
(                storage.virial_tensor\(b, a\) += shift\(b\) * groupForce\(a\);) p n
0 T (              }) N
0 T (            }) N
(1115) # (          }) N
0 T (          groupForce = 0.;) N
0 T (          k = kk;) N
0 T () N
0 T (        }) N
(1120) # () N
0 T (        ) S
(const) K
( ) p
(double) k
( dist2 = abs2\(r\);) p n
0 T (        math::Vec force;) N
0 T (        ) S
(double) k
( f;) p n
0 T (        ) S
(double) k
( e_lj, e_crf;) p n
(1125) # () N
0 T (        innerloop.lj_crf_innerloop_2\(topo, i, *j_it, dist2, f, e_lj, e_crf\);) N
0 T () N
0 T (        ) S
(const) K
( ) p
(unsigned) k
( ) p
(int) k
( eg_j = topo.atom_energy_group\(*j_it\);) p n
0 T (        DEBUG\(11, ") S
(\\tenergy group i ) str
(" << eg_i << ") p
( j ) str
(" << eg_j\);) p n
(1130) # (        storage.energies.lj_energy[eg_i][eg_j] += e_lj;) N
0 T (        storage.energies.crf_energy[eg_i][eg_j] += e_crf;) N
0 T () N
0 T (        force = f * r;) N
0 T (        storage.force\(*j_it\) -= force;) N
(1135) # (        groupForce += force;) N
0 T () N
0 T (        ) S
(//innerloop.lj_crf_innerloop\(topo, conf, i, *j_it, storage, periodicity\)) c n
0 T (;) N
0 T () S
(      }) p n
0 T (    ) N
(1140) # (      storage.force\(i\) += groupForce;) N
0 T (      ) S
(if) K
( \(k != 0\) {) p n
0 T (        ) S
(const) K
( math::Vec shift = periodicity.shift\(k+13\).pos;) p n
0 T (        ) S
(for) K
( \() p
(int) k
( a = 0; a < 3; ++a\) {) p n
0 T (          ) S
(for) K
( \() p
(int) k
( b = 0; b < 3; ++b\) {) p n
(1145) # (            ) S
(//storage.virial_tensor\(b, a\) += \(posI\(b\) + shift\(b\)\) * groupForce\(a) c n
0 T (\);) N
0 T () S
(            storage.virial_tensor\(b, a\) += shift\(b\) * groupForce\(a\);) p n
0 T (          }) N
0 T (        }) N
0 T (      }) N
(1150) # (    }) N
0 T () N
0 T (    ) S
(for) K
( \() p
(unsigned) k
( ) p
(int) k
( ii = end; ii < size_i; ++ii\) {) p n
0 T (      ) S
(const) K
( math::Vec pos = conf.current\(\).pos\(ii\);) p n
0 T (      ) S
(const) K
( math::Vec force = storage.force\(ii\);) p n
(1155) # (      ) S
(for) K
( \() p
(int) k
( a = 0; a < 3; ++a\) {) p n
0 T (        ) S
(for) K
( \() p
(int) k
( b = 0; b < 3; ++b\) {) p n
0 T (          ) S
(//storage.virial_tensor\(b, a\) += \(posI\(b\) + shift\(b\)\) * groupForce\(a\);) c n
0 T () S
(          storage.virial_tensor\(b, a\) += pos\(b\) * force\(a\);) p n
0 T (        }) N
(1160) # (      }) N
0 T (    }) N
0 T (  }) N
0 T (  ) S
(if) K
( \(master\)) p n
0 T (    timer.stop\(timer_name\);) N
(1165) # (}) N
(nonbonded_outerloop.cc) (Page 17/40) (Dec 06, 18 14:53) title
border
/v 1 store
/x0 x v get 2.965278 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
0 T () p n
0 T () N
0 T () S
(// calculate sasa and volume term) c n
0 T () N
(1170) # () S
(void) k
( interaction::Nonbonded_Outerloop) p n
0 T (::sasa_outerloop\(topology::Topology & topo,) N
0 T (        configuration::Configuration & conf,) N
0 T (        simulation::Simulation & sim,) N
0 T (        Storage & storage\) {) N
(1175) # (  SPLIT_INNERLOOP\(_sasa_outerloop, topo, conf, sim,) N
0 T (          storage\);) N
0 T (}) N
0 T () N
0 T () S
(/**) c n
(1180) # ( * helper function to calculate sasa forces and energies) N
0 T ( */) N
0 T () N
0 T () S
(template) K
(<) p
(typename) k
( t_interaction_spec>) p n
0 T () S
(void) k
( interaction::Nonbonded_Outerloop) p n
(1185) # (::_sasa_outerloop\(topology::Topology & topo,) N
0 T (        configuration::Configuration & conf,) N
0 T (        simulation::Simulation & sim,) N
0 T (        Storage & storage\) {) N
0 T () N
(1190) # (  DEBUG\(7, ") S
(\\tCalculating SASA/VOL interaction term) str
("\);) p n
0 T () N
0 T (  math::Periodicity<t_interaction_spec::boundary_type> periodicity\(conf.current\() N
0 T (\).box\);) N
0 T (  Nonbonded_Innerloop<t_interaction_spec> innerloop\(m_param\);) N
0 T () N
(1195) # (  ) S
(// these are the same for every atom, but I only want them if it's volume...) c n
0 T () S
(  ) p
(const) K
( ) p
(double) k
( amin = sim.param\(\).sasa.min_cut;) p n
0 T (  ) S
(const) K
( ) p
(double) k
( amax = sim.param\(\).sasa.max_cut;) p n
0 T (  ) S
(const) K
( ) p
(double) k
( adiff = sim.param\(\).sasa.cut_diff;) p n
0 T () N
(1200) # (  ) S
(// first put surface and area into conf.current) c n
0 T () S
(  ) p
(const) K
( ) p
(unsigned) k
( ) p
(int) k
( num_sasa_atoms = topo.sasa_parameter\(\).size\(\);) p n
0 T (  DEBUG\(15, ") S
(\\tNumber of non-H \(\\"sasa\\"\) atoms: ) str
(" << num_sasa_atoms\);) p n
0 T () N
0 T (  ) S
(for) K
( \() p
(unsigned) k
( ) p
(int) k
( i = 0; i < num_sasa_atoms; ++i\) {) p n
(1205) # () N
0 T (    ) S
(// note that i counts non-H \("sasa"\) atoms) c n
0 T () S
(    DEBUG\(10, ") p
(\\tInitialising surface, area and volume for sasa atom ) str
(" << i\);) p n
0 T (    ) S
(// get sasa parameters for atom i) c n
0 T () S
(    ) p
(const) K
( topology::sasa_parameter_struct & sasa_param_i = topo.sasa_parameter\(i) p n
0 T (\);) N
(1210) # (    ) S
(// initialise actual sasa array \(size = num_sasa_atoms\)) c n
0 T () S
(    conf.current\(\).sasa_area[i] = sasa_param_i.surface;) p n
0 T () N
0 T (  } ) S
(// end initialize surface areas) c n
0 T () N
(1215) # () S
(  ) p
(// now compute actual sasa \(reduction due to overlap\)) c n
0 T () S
(  ) p
(for) K
( \() p
(unsigned) k
( ) p
(int) k
( i = 0; i < num_sasa_atoms; ++i\) {) p n
0 T () N
0 T (    DEBUG\(10, ") S
(\\tCalculating true SASA for sasa atom ) str
(" << i\);) p n
0 T (    innerloop.sasa_calc_innerloop\(topo, conf, i, sim, periodicity\);) N
(1220) # () N
0 T (  } ) S
(// end compute sasa) c n
0 T () N
0 T () S
(  ) p
(// store final and total sasas and their energy contribution,) c n
0 T () S
(  ) p
(// compute volume term and compute forces) c n
(1225) # () S
(  ) p
(for) K
( \() p
(unsigned) k
( ) p
(int) k
( i = 0; i < num_sasa_atoms; ++i\) {) p n
0 T () N
0 T (    ) S
(// check for negative SASA) c n
0 T () S
(    DEBUG\(10, ") p
(\\tChecking for negative true SASA for sasa atom ) str
(" << i\);) p n
0 T (    ) S
(if) K
( \(conf.current\(\).sasa_area[i] < 0\) {) p n
(1230) # (      io::messages.add\(") S
(Nonbonded_Outerloop) str
(",) p n
0 T (              ") S
(negative SASA) str
(", io::message::critical\);) p n
0 T (    } ) S
(else) K
( {) p n
0 T (      DEBUG\(10, ") S
(\\tStoring true SASA and energies for sasa atom ) str
(" << i\);) p n
0 T () N
(1235) # (      ) S
(// get sasa parameters for atom i) c n
0 T () S
(      ) p
(const) K
( topology::sasa_parameter_struct & sasa_param_i = topo.sasa_parameter) p n
(nonbonded_outerloop.cc) (Page 18/40) (Dec 06, 18 14:53) title
border
grestore
(Printed by Patrick Bleiziffer) rhead
(nonbonded_outerloop.cc) (9/20) (Thursday December 06, 2018) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (19-20) 10
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 2.965278 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
0 T (\(i\);) p n
0 T (      ) S
(// add sasa to total) c n
0 T () S
(      conf.current\(\).sasa_tot += conf.current\(\).sasa_area[i];) p n
0 T () N
(1240) # (      DEBUG\(15, ") S
(\\tSASA of atom ) str
(" << sasa_param_i.atom << ") p
( is ) str
(" << conf.current\(\).sa) p n
0 T (sa_area[i]) N
0 T (              << ") S
(\\tand current total SASA of molecule is ) str
(" << conf.current\(\).sasa_tot\);) p n
0 T () N
0 T (      ) S
(double) k
( e_sasa = conf.current\(\).sasa_area[i] * sasa_param_i.sigma;) p n
0 T (      conf.current\(\).energies.sasa_energy[topo.atom_energy_group\(sasa_param_i.at) N
0 T (om\)] += e_sasa;) N
(1245) # () N
0 T (      DEBUG\(15, ") S
(\\tSASA energy of atom ) str
(" << sasa_param_i.atom << ") p
( is ) str
(" << e_sasa) p n
0 T (              << ") S
(\\tand current total SASA energy is ) str
(" <<) p n
0 T (              conf.current\(\).energies.sasa_energy[topo.atom_energy_group\(sasa_pa) N
0 T (ram_i.atom\)]\);) N
0 T () N
(1250) # (      ) S
(// if using volume too, compute volume term for atom i) c n
0 T () S
(      ) p
(// has to go here because the switching function needs the true area) c n
0 T () S
(      ) p
(if) K
( \(sim.param\(\).sasa.switch_volume\) {) p n
0 T (        DEBUG\(10, ") S
(\\tComputing volume term for sasa atom ) str
(" << i\);) p n
0 T (        ) S
(// first compute switching function and its derivative \(for later\)) c n
(1255) # () S
(        innerloop.sasa_switching_fct\(conf, i, amin, amax, adiff\);) p n
0 T (        ) S
(// compute volume contribution to energy) c n
0 T () S
(        innerloop.sasa_volume_innerloop\(topo, conf, i, sim\);) p n
0 T (      }) N
0 T (    } ) S
(// end else) c n
(1260) # () S
(  } ) p
(// end atoms i) c n
0 T () N
0 T () S
(  ) p
(// finally calculate the forces \(for sasa and, if used, vol\)) c n
0 T () S
(  ) p
(// has to be in a separate loop because we need the switching function derivat) c n
0 T (ive) N
0 T () S
(  ) p
(// for all atoms to have been computed) c n
(1265) # () S
(  ) p
(for) K
( \() p
(unsigned) k
( ) p
(int) k
( i = 0; i < num_sasa_atoms; ++i\) {) p n
0 T (    DEBUG\(10, ") S
(\\tCalculating SASA/VOL forces for sasa atom ) str
(" << i\);) p n
0 T (    innerloop.sasa_force_innerloop\(topo, conf, i, sim, periodicity\);) N
0 T () N
0 T (  }) N
(1270) # () N
0 T (}) N
0 T () N
0 T () S
(/**) c n
0 T ( * helper function to calculate the forces and energies from the) N
(1275) # ( * 1,4 interactions.) N
0 T ( */) N
0 T () S
(void) k
( interaction::Nonbonded_Outerloop) p n
0 T (::one_four_outerloop\(topology::Topology & topo,) N
0 T (        configuration::Configuration & conf,) N
(1280) # (        simulation::Simulation & sim,) N
0 T (        Storage & storage,) N
0 T (        ) S
(int) k
( rank, ) p
(int) k
( size\) {) p n
0 T (  SPLIT_INNERLOOP\(_one_four_outerloop, topo, conf, sim, storage, rank, size\);) N
0 T (}) N
(1285) # () N
0 T () S
(/**) c n
0 T ( * helper function to calculate the forces and energies from the) N
0 T ( * 1,4 interactions.) N
0 T ( */) N
(1290) # () S
(template) K
(<) p
(typename) k
( t_interaction_spec>) p n
0 T () S
(void) k
( interaction::Nonbonded_Outerloop) p n
0 T (::_one_four_outerloop\(topology::Topology & topo,) N
0 T (        configuration::Configuration & conf,) N
0 T (        simulation::Simulation & sim,) N
(1295) # (        Storage & storage,) N
0 T (        ) S
(int) k
( rank, ) p
(int) k
( size\) {) p n
0 T (  DEBUG\(7, ") S
(\\tcalculate 1,4-interactions) str
("\);) p n
0 T () N
0 T (  math::Periodicity<t_interaction_spec::boundary_type> periodicity\(conf.current\() N
0 T (\).box\);) N
(1300) # (  Nonbonded_Innerloop<t_interaction_spec> innerloop\(m_param\);) N
0 T (  innerloop.init\(sim\);) N
0 T () N
0 T (  topology::excl_cont_t::value_type::const_iterator it, to;) N
(nonbonded_outerloop.cc) (Page 19/40) (Dec 06, 18 14:53) title
border
/v 1 store
/x0 x v get 2.965278 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
0 T (  ) p
(unsigned) k
( ) p
(int) k
( ) p
(const) K
( num_solute_atoms = topo.num_solute_atoms\(\);) p n
(1305) # () N
0 T (  ) S
(for) K
( \() p
(unsigned) k
( ) p
(int) k
( i = rank; i < num_solute_atoms; i += size\) {) p n
0 T (    it = topo.one_four_pair\(i\).begin\(\);) N
0 T (    to = topo.one_four_pair\(i\).end\(\);) N
0 T () N
(1310) # (    ) S
(for) K
( \(; it != to; ++it\) {) p n
0 T () N
0 T (      innerloop.one_four_interaction_innerloop\(topo, conf, i, *it, storage, peri) N
0 T (odicity\);) N
0 T () N
0 T (    } ) S
(// loop over 1,4 pairs) c n
(1315) # () S
(  } ) p
(// loop over solute atoms) c n
0 T () S
(}) p n
0 T () N
0 T () S
(/**) c n
0 T ( * helper function to calculate the forces and energies from the) N
(1320) # ( * Lennard-Jones exception interaction) N
0 T ( */) N
0 T () S
(void) k
( interaction::Nonbonded_Outerloop) p n
0 T (::lj_exception_outerloop\(topology::Topology & topo,) N
0 T () S 8 T () S 16 T (     configuration::Configuration & conf,) N
(1325) # () S 8 T () S 16 T (     simulation::Simulation & sim,) N
0 T () S 8 T () S 16 T (     Storage & storage,) N
0 T (                     ) S
(int) k
( rank, ) p
(int) k
( size\)) p n
0 T ({) N
0 T (  SPLIT_INNERLOOP\(_lj_exception_outerloop, topo, conf, sim, storage, rank, size\)) N
0 T (;) N
(1330) # (}) N
0 T () N
0 T () S
(/**) c n
0 T ( * helper function to calculate the forces and energies from the) N
0 T ( * Lennard-Jones exception interaction) N
(1335) # ( */) N
0 T () S
(template) K
(<) p
(typename) k
( t_interaction_spec>) p n
0 T () S
(void) k
( interaction::Nonbonded_Outerloop) p n
0 T (::_lj_exception_outerloop\(topology::Topology & topo,) N
0 T () S 8 T () S 16 T (     configuration::Configuration & conf,) N
(1340) # () S 8 T () S 16 T (     simulation::Simulation & sim,) N
0 T () S 8 T () S 16 T (     Storage & storage,) N
0 T (                     ) S
(int) k
( rank, ) p
(int) k
( size\)) p n
0 T ({) N
0 T (  DEBUG\(7, ") S
(\\tcalculate Lennard-Jones-exception-interactions) str
("\);) p n
(1345) # () N
0 T (  math::Periodicity<t_interaction_spec::boundary_type> periodicity\(conf.current\() N
0 T (\).box\);) N
0 T (  Nonbonded_Innerloop<t_interaction_spec> innerloop\(m_param\);) N
0 T (  innerloop.init\(sim\);) N
0 T (  ) S
(unsigned) k
( ) p
(int) k
( ) p
(const) K
( num_lj_exceptions = topo.lj_exceptions\(\).size\(\);) p n
(1350) # () N
0 T (  ) S
(for) K
( \() p
(unsigned) k
( ) p
(int) k
( i = rank; i < num_lj_exceptions; i += size\) {) p n
0 T (    ) S
(const) K
( topology::lj_exception_struct & ljex = topo.lj_exceptions\(\)[i];) p n
0 T () N
0 T (    innerloop.lj_exception_innerloop\(topo, conf, ljex, storage, periodicity\);) N
(1355) # (  } ) S
(// loop over LJ exceptions) c n
0 T () S
(}) p n
0 T () N
0 T () S
(/**) c n
0 T ( * helper function to calculate the forces and energies from the) N
(1360) # ( * 1,4 interactions.) N
0 T ( */) N
0 T () S
(void) k
( interaction::Nonbonded_Outerloop) p n
0 T (::cg_exclusions_outerloop\(topology::Topology & topo,) N
0 T (        configuration::Configuration & conf,) N
(1365) # (        simulation::Simulation & sim,) N
0 T (        Storage & storage\) {) N
0 T (  SPLIT_INNERLOOP\(_cg_exclusions_outerloop, topo, conf, sim, storage\);) N
0 T (}) N
0 T () N
(1370) # () S
(template) K
(<) p
(typename) k
( t_interaction_spec>) p n
0 T () S
(void) k
( interaction::Nonbonded_Outerloop) p n
0 T (::_cg_exclusions_outerloop\(topology::Topology & topo,) N
0 T (        configuration::Configuration & conf,) N
(nonbonded_outerloop.cc) (Page 20/40) (Dec 06, 18 14:53) title
border
grestore
(Printed by Patrick Bleiziffer) rhead
(nonbonded_outerloop.cc) (10/20) (Thursday December 06, 2018) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (21-22) 11
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 2.965278 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
0 T (        simulation::Simulation & sim,) p n
(1375) # (        Storage & storage\) {) N
0 T (  DEBUG\(7, ") S
(\\tcalculate 1,4-interactions) str
("\);) p n
0 T () N
0 T (  math::Periodicity<t_interaction_spec::boundary_type> periodicity\(conf.current\() N
0 T (\).box\);) N
0 T (  Nonbonded_Innerloop<t_interaction_spec> innerloop\(m_param\);) N
(1380) # (  innerloop.init\(sim\);) N
0 T () N
0 T (  std::set<) S
(int) k
(>::const_iterator cg2_it, cg2_to;) p n
0 T () N
0 T (  ) S
(for) K
( \() p
(unsigned) k
( ) p
(int) k
( cg1 = 0; cg1 < topo.num_solute_chargegroups\(\); ++cg1\) {) p n
(1385) # () N
0 T (    cg2_it = topo.chargegroup_exclusion\(cg1\).begin\(\);) N
0 T (    cg2_to = topo.chargegroup_exclusion\(cg1\).end\(\);) N
0 T () N
0 T (    ) S
(for) K
( \(; cg2_it != cg2_to; ++cg2_it\) {) p n
(1390) # () N
0 T (      ) S
(// only once...) c n
0 T () S
(      ) p
(if) K
( \(cg1 > \() p
(unsigned) k
(\) * cg2_it\) ) p
(continue) K
(;) p n
0 T () N
0 T (      ) S
(for) K
( \() p
(int) k
( a1 = topo.chargegroup\(cg1\); a1 < topo.chargegroup\(cg1 + 1\); ++a1\)) p n
0 T ( {) N
(1395) # (        ) S
(for) K
( \() p
(int) k
( a2 = topo.chargegroup\(*cg2_it\); a2 < topo.chargegroup\(*cg2_it +) p n
0 T ( 1\); ++a2\) {) N
0 T () N
0 T (          ) S
(// std::cout << "cg1=" << cg1 << " cg2=" << *cg2_it) c n
0 T () S
(          ) p
(// << " a1=" << a1 << " a2=" << a2 << std::endl;) c n
0 T () N
(1400) # () S
(          ) p
(if) K
( \(a1 >= a2\) ) p
(continue) K
(;) p n
0 T () N
0 T (          ) S
(if) K
( \(std::find\(topo.exclusion\(a1\).begin\(\), topo.exclusion\(a1\).end\(\), a2) p n
0 T (\) ) N
0 T (              != topo.exclusion\(a1\).end\(\)\) ) S
(continue) K
(;) p n
0 T () N
(1405) # (          ) S
(if) K
( \(std::find\(topo.one_four_pair\(a1\).begin\(\), topo.one_four_pair\(a1\).e) p n
0 T (nd\(\), a2\) ) N
0 T (              != topo.one_four_pair\(a1\).end\(\)\) {) N
0 T (            ) S
(// std::cout << "\\t1,4" << std::endl;) c n
0 T () S
(            innerloop.one_four_interaction_innerloop\(topo, conf, a1, a2, storage) p n
0 T (, periodicity\);) N
0 T (          } ) S
(else) K
( {) p n
(1410) # (            ) S
(// std::cout << "\\tstandard interaction" << std::endl;) c n
0 T () S
(            innerloop.lj_crf_innerloop\(topo, conf, a1, a2, storage, periodicity\)) p n
0 T (;) N
0 T (          }) N
0 T (        } ) S
(// atoms of cg 2) c n
0 T () S
(      } ) p
(// atoms of cg 1) c n
(1415) # () N
0 T () S
(    } ) p
(// cg 2 \(excluded from cg 1\)) c n
0 T () S
(  } ) p
(// solute cg's) c n
0 T () S
(}) p n
0 T () N
(1420) # () S
(/**) c n
0 T ( * helper function to calculate the forces and energies from the) N
0 T ( * RF contribution of excluded atoms and self term) N
0 T ( */) N
0 T () S
(void) k
( interaction::Nonbonded_Outerloop) p n
(1425) # (::RF_excluded_outerloop\(topology::Topology & topo,) N
0 T (        configuration::Configuration & conf,) N
0 T (        simulation::Simulation & sim,) N
0 T (        Storage & storage,) N
0 T (        ) S
(int) k
( rank, ) p
(int) k
( size\) {) p n
(1430) # (  ) S
(/*) c n
0 T (  if \(sim.param\(\).force.interaction_function !=) N
0 T (      simulation::lj_crf_func &&) N
0 T (      sim.param\(\).force.interaction_function !=) N
0 T (      simulation::pol_lj_crf_func\){) N
(1435) # (    io::messages.add\("Nonbonded_Outerloop",) N
0 T (             "RF excluded term for non-lj_crf_func called",) N
0 T (             io::message::error\);) N
0 T (  }) N
0 T (   */) N
(nonbonded_outerloop.cc) (Page 21/40) (Dec 06, 18 14:53) title
border
/v 1 store
/x0 x v get 2.965278 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(1440) # () p n
0 T (  SPLIT_INNERLOOP\(_RF_excluded_outerloop, topo, conf, sim, storage, rank, size\);) N
0 T (}) N
0 T () N
0 T () S
(/**) c n
(1445) # ( * helper function to calculate the forces and energies from the) N
0 T ( * RF contribution of excluded atoms and self term) N
0 T ( */) N
0 T () S
(template) K
(<) p
(typename) k
( t_interaction_spec>) p n
0 T () S
(void) k
( interaction::Nonbonded_Outerloop) p n
(1450) # (::_RF_excluded_outerloop\(topology::Topology & topo,) N
0 T (        configuration::Configuration & conf,) N
0 T (        simulation::Simulation & sim,) N
0 T (        Storage & storage,) N
0 T (        ) S
(int) k
( rank, ) p
(int) k
( size\) {) p n
(1455) # () N
0 T (  DEBUG\(7, ") S
(\\tcalculate RF excluded interactions) str
("\);) p n
0 T () N
0 T (  math::Periodicity<t_interaction_spec::boundary_type> periodicity\(conf.current\() N
0 T (\).box\);) N
0 T (  Nonbonded_Innerloop<t_interaction_spec> innerloop\(m_param\);) N
(1460) # (  innerloop.init\(sim\);) N
0 T () N
0 T (  ) S
(const) K
( ) p
(unsigned) k
( ) p
(int) k
( num_solute_atoms = topo.num_solute_atoms\(\);) p n
0 T () N
0 T (  ) S
(for) K
( \() p
(unsigned) k
( ) p
(int) k
( i = rank; i < num_solute_atoms; i += size\) {) p n
(1465) # (    innerloop.RF_excluded_interaction_innerloop\(topo, conf, i, storage, periodic) N
0 T (ity\);) N
0 T (  } ) S
(// loop over solute atoms) c n
0 T () N
0 T () S
(  ) p
(// Solvent) c n
0 T () S
(  topology::Chargegroup_Iterator cg_it = topo.chargegroup_begin\(\),) p n
(1470) # (          cg_to = topo.chargegroup_end\(\);) N
0 T (  cg_it += topo.num_solute_chargegroups\(\) + rank;) N
0 T () N
0 T (  ) S
(for) K
( \(; cg_it < cg_to; cg_it += size\) {) p n
0 T (    innerloop.RF_solvent_interaction_innerloop\(topo, conf, cg_it, storage, perio) N
0 T (dicity\);) N
(1475) # (  } ) S
(// loop over solvent charge groups) c n
0 T () S
(}) p n
0 T () N
0 T () S
(void) k
( interaction::Nonbonded_Outerloop) p n
0 T (::self_energy_outerloop\(topology::Topology & topo,) N
(1480) # (        configuration::Configuration & conf,) N
0 T (        simulation::Simulation & sim,) N
0 T (        Storage & storage\) {) N
0 T (  SPLIT_INNERLOOP\(_self_energy_outerloop, topo, conf, sim, storage\);) N
0 T (}) N
(1485) # () N
0 T () S
(/**) c n
0 T ( * helper function to calculate self energy, ) N
0 T ( * stores them in the arrays pointed to by parameters) N
0 T ( * to make it usable for longrange calculations.) N
(1490) # ( */) N
0 T () S
(template) K
(<) p
(typename) k
( t_interaction_spec>) p n
0 T () S
(void) k
( interaction::Nonbonded_Outerloop) p n
0 T (::_self_energy_outerloop\(topology::Topology & topo,) N
0 T (        configuration::Configuration & conf,) N
(1495) # (        simulation::Simulation & sim,) N
0 T (        Storage & storage\) {) N
0 T (  math::Periodicity<t_interaction_spec::boundary_type> periodicity\(conf.current\() N
0 T (\).box\);) N
0 T (  Nonbonded_Innerloop<t_interaction_spec> innerloop\(m_param\);) N
0 T (  innerloop.init\(sim\);) N
(1500) # () N
0 T (  ) S
(for) K
( \() p
(unsigned) k
( ) p
(int) k
( i = 0; i < topo.num_atoms\(\); ++i\) {) p n
0 T (    ) S
(if) K
( \(topo.is_polarisable\(i\)\) {) p n
0 T () N
0 T (      DEBUG\(10, ") S
(\\tself energy: i ) str
(" << i\);) p n
(1505) # (      innerloop.self_energy_innerloop\() N
0 T (              topo, conf, i, storage, periodicity\);) N
0 T (    }) N
0 T (  }) N
(nonbonded_outerloop.cc) (Page 22/40) (Dec 06, 18 14:53) title
border
grestore
(Printed by Patrick Bleiziffer) rhead
(nonbonded_outerloop.cc) (11/20) (Thursday December 06, 2018) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (23-24) 12
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 2.965278 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
0 T (}) p n
(1510) # () N
0 T () S
(void) k
( interaction::Nonbonded_Outerloop) p n
0 T (::electric_field_outerloop\(topology::Topology & topo,) N
0 T (        configuration::Configuration & conf,) N
0 T (        simulation::Simulation & sim,) N
(1515) # (        PairlistContainer ) S
(const) K
( & pairlist,) p n
0 T (        Storage & storage,) N
0 T (        Storage & storage_lr, ) S
(int) k
( rank\) {) p n
0 T (  SPLIT_INNERLOOP\(_electric_field_outerloop, topo, conf, sim,) N
0 T (          pairlist, storage, storage_lr, rank\);) N
(1520) # (}) N
0 T () N
0 T () S
(/**) c n
0 T ( * helper function to calculate polarisation, ) N
0 T ( * stores them in the arrays pointed to by parameters) N
(1525) # ( * to make it usable for longrange calculations.) N
0 T ( */) N
0 T () S
(template) K
(<) p
(typename) k
( t_interaction_spec>) p n
0 T () S
(void) k
( interaction::Nonbonded_Outerloop) p n
0 T (::_electric_field_outerloop\(topology::Topology & topo,) N
(1530) # (        configuration::Configuration & conf,) N
0 T (        simulation::Simulation & sim,) N
0 T (        PairlistContainer ) S
(const) K
( & pairlist,) p n
0 T (        Storage & storage,) N
0 T (        Storage & storage_lr,) N
(1535) # (        ) S
(int) k
( rank\) {) p n
0 T (  DEBUG\(7, ") S
(\\tcalculate polarisation \(electric field outerloop\)) str
("\);) p n
0 T () N
0 T (  math::Periodicity<t_interaction_spec::boundary_type> periodicity\(conf.current\() N
0 T (\).box\);) N
0 T (  Nonbonded_Innerloop<t_interaction_spec> innerloop\(m_param\);) N
(1540) # (  innerloop.init\(sim\);) N
0 T (  ) S
(unsigned) k
( ) p
(int) k
( i;) p n
0 T (  ) S
(unsigned) k
( ) p
(int) k
( size_i = ) p
(unsigned) k
(\(pairlist.size\(\)\);) p n
0 T (  ) S
(unsigned) k
( ) p
(int) k
( size_lr = size_i;) p n
0 T (  DEBUG\(11, ") S
(el_field outerloop pairlist size ) str
(" << size_i\);) p n
(1545) # () N
0 T (  ) S
(unsigned) k
( ) p
(int) k
( end = size_i;) p n
0 T (  ) S
(unsigned) k
( ) p
(int) k
( end_lr = size_lr;) p n
0 T () N
0 T (  ) S
(if) K
( \(rank == 0\) {) p n
(1550) # (    ) S
(// compute the QM part, gather etc...) c n
0 T () S
(    ) p
(if) K
( \(sim.param\(\).qmmm.qmmm != simulation::qmmm_off\) {) p n
0 T (      sim.param\(\).qmmm.interaction->prepare\(topo, conf, sim\);) N
0 T (    }) N
0 T (  }) N
(1555) # () N
0 T (  math::VArray e_el_new\(topo.num_atoms\(\)\);) N
0 T () S
(#ifdef) K
( XXMPI) p n
0 T (  ) S
(// because we need some place to reduce the field to) c n
0 T () S
(  math::VArray e_el_master\(topo.num_atoms\(\)\);) p n
(1560) # () S
(#endif) K n
0 T () N
0 T () S
(  ) p
(double) k
( minfield = sim.param\(\).polarise.minfield;) p n
0 T (  ) S
(const) K
( ) p
(double) k
( minfield_param = minfield;) p n
0 T (  ) S
(double) k
( maxfield;) p n
(1565) # (  ) S
(int) k
( turni = 0;) p n
0 T () N
0 T () S
(#ifdef) K
( XXMPI) p n
0 T (  ) S
(// broadcast posV to slaves. We only have to do this here at the very first st) c n
0 T (ep because) N
0 T () S
(  ) p
(// posV is also broadcasted at the end of every electric field iteration.) c n
(1570) # () S
(  ) p
(if) K
( \(sim.mpi && sim.steps\(\) == 0\) {) p n
0 T (    MPI::COMM_WORLD.Bcast\(&conf.current\(\).posV\(0\)\(0\), conf.current\(\).posV.size\(\)) N
0 T ( * 3, MPI::DOUBLE, 0\);) N
0 T (  }) N
0 T () S
(#endif) K n
0 T () N
(1575) # () S
(  ) p
(// longrange ?) c n
0 T () S
(  ) p
(if) K
( \(!\(sim.steps\(\) % sim.param\(\).pairlist.skip_step\)\) {) p n
0 T () N
0 T (    ) S
(// loop over all molecules in longrange pairlist) c n
(nonbonded_outerloop.cc) (Page 23/40) (Dec 06, 18 14:53) title
border
/v 1 store
/x0 x v get 2.965278 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
0 T (    ) p
(for) K
( \(i = 0; i < end_lr; ++i\) {) p n
(1580) # (      ) S
(// solute longrange) c n
0 T () S
(      ) p
(for) K
( \(std::vector<) p
(unsigned) k
( ) p
(int) k
(>::const_iterator) p n
0 T (        j_it = pairlist.solute_long[i].begin\(\),) N
0 T (              j_to = pairlist.solute_long[i].end\(\);) N
0 T (              j_it != j_to; ++j_it\){) N
(1585) # () N
0 T (        ) S
(if) K
( \(!topo.is_polarisable\(i\) && !topo.is_polarisable\(*j_it\)\) ) p
(continue) K
(;) p n
0 T (        math::Vec e_eli_lr, e_elj_lr;) N
0 T () N
0 T (        innerloop.electric_field_innerloop\(topo, conf, i, *j_it,) N
(1590) # (                e_eli_lr, e_elj_lr, periodicity\);) N
0 T () N
0 T (        storage_lr.electric_field[i] += e_eli_lr;) N
0 T (        storage_lr.electric_field[*j_it] += e_elj_lr;) N
0 T (      }) N
(1595) # (      ) S
(// solvent longrange) c n
0 T () S
(      ) p
(for) K
( \(std::vector<) p
(unsigned) k
( ) p
(int) k
(>::const_iterator) p n
0 T (        j_it = pairlist.solvent_long[i].begin\(\),) N
0 T (              j_to = pairlist.solvent_long[i].end\(\);) N
0 T (              j_it != j_to; ++j_it\){) N
(1600) # (        ) S
(if) K
( \(!topo.is_polarisable\(i\) && !topo.is_polarisable\(*j_it\)\) ) p
(continue) K
(;) p n
0 T (        math::Vec e_eli_lr, e_elj_lr;) N
0 T () N
0 T (        innerloop.electric_field_innerloop\(topo, conf, i, *j_it,) N
0 T (                e_eli_lr, e_elj_lr, periodicity\);) N
(1605) # () N
0 T (        storage_lr.electric_field[i] += e_eli_lr;) N
0 T (        storage_lr.electric_field[*j_it] += e_elj_lr;) N
0 T (      }) N
0 T (    }) N
(1610) # () S
(#ifdef) K
( XXMPI) p n
0 T (    ) S
(if) K
( \(sim.mpi\) {) p n
0 T (      ) S
(// reduce the longrange electric field to some temp. variable and then set) c n
0 T ( this) N
0 T () S
(      ) p
(// variable to the longrange electric field on the master. The lr e field) c n
0 T () S
(      ) p
(// is only needed on the master node) c n
(1615) # () S
(      ) p
(if) K
( \(rank\) {) p n
0 T (        MPI::COMM_WORLD.Reduce\(&storage_lr.electric_field\(0\)\(0\), ) S
(NULL) K
(,) p n
0 T (                storage_lr.electric_field.size\(\) * 3, MPI::DOUBLE, MPI::SUM, 0\);) N
0 T (      } ) S
(else) K
( {) p n
0 T (        MPI::COMM_WORLD.Reduce\(&storage_lr.electric_field\(0\)\(0\), &e_el_master\(0\)) N
0 T (\(0\),) N
(1620) # (                storage_lr.electric_field.size\(\) * 3, MPI::DOUBLE, MPI::SUM, 0\);) N
0 T (        storage_lr.electric_field = e_el_master;) N
0 T (      }) N
0 T (    }) N
0 T () S
(#endif) K n
(1625) # () S
(  }) p n
0 T () N
0 T (  ) S
(// shortrange) c n
0 T () S
(  ) p
(while) K
( \(minfield >= minfield_param\) {) p n
0 T () N
(1630) # (    maxfield = 0.0;) N
0 T (    e_el_new = 0.0;) N
0 T () S
(#ifdef) K
( XXMPI) p n
0 T (    ) S
(// again set the temporary variable to 0 as we need it again for ) c n
0 T () S
(    ) p
(// the short range eletric field) c n
(1635) # () S
(    ) p
(if) K
( \(sim.mpi\)) p n
0 T (      e_el_master = 0.0;) N
0 T () S
(#endif) K n
0 T () N
0 T () S
(    ) p
(// loop over all molecules in shortrange pairlist) c n
(1640) # () S
(    ) p
(for) K
( \(i = 0; i < end; ++i\) {) p n
0 T (      ) S
(// solute short) c n
0 T () S
(      ) p
(for) K
( \(std::vector<) p
(unsigned) k
( ) p
(int) k
(>::const_iterator) p n
0 T (        j_it = pairlist.solute_short[i].begin\(\),) N
0 T (              j_to = pairlist.solute_short[i].end\(\);) N
(1645) # (              j_it != j_to; ++j_it\) {) N
0 T (        ) S
(if) K
( \(!topo.is_polarisable\(i\) && !topo.is_polarisable\(*j_it\)\) ) p
(continue) K
(;) p n
0 T (        math::Vec e_eli, e_elj;) N
0 T () N
0 T (        innerloop.electric_field_innerloop\(topo, conf,) N
(nonbonded_outerloop.cc) (Page 24/40) (Dec 06, 18 14:53) title
border
grestore
(Printed by Patrick Bleiziffer) rhead
(nonbonded_outerloop.cc) (12/20) (Thursday December 06, 2018) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (25-26) 13
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 2.965278 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(1650) # (                i, *j_it, e_eli, e_elj, periodicity\);) p n
0 T () N
0 T (        e_el_new\(i\) += e_eli;) N
0 T (        e_el_new\(*j_it\) += e_elj;) N
0 T (      }) N
(1655) # (      ) S
(// solvent short) c n
0 T () S
(      ) p
(for) K
( \(std::vector<) p
(unsigned) k
( ) p
(int) k
(>::const_iterator) p n
0 T (        j_it = pairlist.solvent_short[i].begin\(\),) N
0 T (              j_to = pairlist.solvent_short[i].end\(\);) N
0 T (              j_it != j_to; ++j_it\) {) N
(1660) # (        ) S
(if) K
( \(!topo.is_polarisable\(i\) && !topo.is_polarisable\(*j_it\)\) ) p
(continue) K
(;) p n
0 T (        math::Vec e_eli, e_elj;) N
0 T () N
0 T (        innerloop.electric_field_innerloop\(topo, conf,) N
0 T (                i, *j_it, e_eli, e_elj, periodicity\);) N
(1665) # () N
0 T (        e_el_new\(i\) += e_eli;) N
0 T (        e_el_new\(*j_it\) += e_elj;) N
0 T (      }) N
0 T (    }) N
(1670) # () N
0 T () S
(#ifdef) K
( XXMPI) p n
0 T (    ) S
(// also reduce the shortrange electric field the same way as the longrange) c n
0 T () S
(    ) p
(// electric field) c n
0 T () S
(    ) p
(if) K
( \(sim.mpi\) {) p n
(1675) # (      ) S
(if) K
( \(rank\) {) p n
0 T (        MPI::COMM_WORLD.Reduce\(&e_el_new\(0\)\(0\), ) S
(NULL) K
(, e_el_new.size\(\) * 3, MPI::) p n
0 T (DOUBLE, MPI::SUM, 0\);) N
0 T (      } ) S
(else) K
( {) p n
0 T (        MPI::COMM_WORLD.Reduce\(&e_el_new\(0\)\(0\), &e_el_master\(0\)\(0\), e_el_new.siz) N
0 T (e\(\) * 3, MPI::DOUBLE, MPI::SUM, 0\);) N
0 T (        e_el_new = e_el_master;) N
(1680) # (      }) N
0 T (    }) N
0 T () S
(#endif) K n
0 T () N
0 T () S
(    ) p
(if) K
( \(rank == 0\) {) p n
(1685) # (      ) S
(// get the contributions from the QM part.) c n
0 T () S
(      ) p
(if) K
( \(sim.param\(\).qmmm.qmmm != simulation::qmmm_off\) {) p n
0 T (        sim.param\(\).qmmm.interaction->) N
0 T (                add_electric_field_contribution\(topo, conf, sim, e_el_new\);) N
0 T (      }) N
(1690) # (      ) N
0 T (      ) S
(// If the external electric field is activated) c n
0 T () S
(      ) p
(// then it will also act on the polarisable model) c n
0 T () S
(      ) p
(// as a perturbation to the COS electric field) c n
0 T () S
(      math::Vec external_field\(sim.param\(\).electric.Ef_x,) p n
(1695) # (                               sim.param\(\).electric.Ef_y,) N
0 T (                               sim.param\(\).electric.Ef_z\);) N
0 T (      external_field *= math::four_pi_eps_i * 3 * sim.param\(\).nonbonded.rf_epsil) N
0 T (on / \(2 * sim.param\(\).nonbonded.rf_epsilon) N
0 T (              + sim.param\(\).nonbonded.epsilon\);) N
0 T (      ) N
(1700) # (      ) S
(for) K
( \(i=0; i<topo.num_atoms\(\); ++i\) {) p n
0 T (        ) S
(if) K
(\(topo.is_polarisable\(i\)\){) p n
0 T (          e_el_new\(i\) += storage_lr.electric_field\(i\) + \(external_field\);) N
0 T (          ) N
0 T (          ) S
(//delta r) c n
(1705) # () S
(          math::Vec delta_r;) p n
0 T () N
0 T (          ) S
(//////////////////////////////////////////////////) c n
0 T () S
(          ) p
(// implementation of polarisability damping) c n
0 T () S
(          ) p
(/////////////////////////////////////////////////) c n
(1710) # () N
0 T () S
(          ) p
(if) K
( \(sim.param\(\).polarise.damp\) { ) p
(// damp the polarisability) c n
0 T () S
(            ) p
(const) K
( ) p
(double) k
( e_i = sqrt\(math::abs2\(e_el_new\(i\)\)\),) p n
0 T (                    e_0 = topo.damping_level\(i\);) N
0 T (            ) S
(if) K
( \(e_i <= e_0\)) p n
(1715) # (              delta_r = \(topo.polarisability\(i\) / topo.coscharge\(i\)\) * e_el_new\() N
0 T (i\);) N
0 T (            ) S
(else) K
( {) p n
0 T (              ) S
(const) K
( ) p
(double) k
( p = topo.damping_power\(i\);) p n
0 T (              delta_r = topo.polarisability\(i\) * e_0  * ) N
(nonbonded_outerloop.cc) (Page 25/40) (Dec 06, 18 14:53) title
border
/v 1 store
/x0 x v get 2.965278 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
0 T (                        \(p + 1.0 - pow\(e_0/e_i, p\)\) / ) p n
(1720) # (                        \(p * topo.coscharge\(i\) * e_i\) * e_el_new\(i\);) N
0 T (            }) N
0 T (          } ) S
(else) K
( { ) p
(// no damping) c n
0 T () S
(            delta_r = \(topo.polarisability\(i\) / topo.coscharge\(i\)\) * e_el_new\(i\)) p n
0 T (;) N
0 T (          }) N
(1725) # (          ) S
(// store the new position) c n
0 T () S
(          conf.current\(\).posV\(i\) = delta_r;) p n
0 T () N
0 T (          ) S
(// calculation of convergence criterium) c n
0 T () S
(          ) p
(for) K
( \() p
(int) k
( j = 0; j < 3; ++j\) {) p n
(1730) # (            ) S
(double) k
( delta_field = fabs\(storage.electric_field\(i\)\(j\) - e_el_new\(i\)) p n
0 T (\(j\)\);) N
0 T (            ) S
(if) K
( \(delta_field > maxfield\) {) p n
0 T (              maxfield = delta_field;) N
0 T (            }) N
0 T (          }) N
(1735) # (        }) N
0 T () N
0 T (        storage.electric_field\(i\) = e_el_new\(i\);) N
0 T (      }) N
0 T (    } ) S
(// end if rank==0) c n
(1740) # () S
(    turni++;) p n
0 T (    minfield = maxfield;) N
0 T () N
0 T () S
(#ifdef) K
( XXMPI) p n
0 T (    ) S
(// broadcast the new posV and also the convergence criterium \(minfield\)) c n
(1745) # () S
(    ) p
(// to the slaves. Otherwise they don't know when to stop.) c n
0 T () S
(    ) p
(if) K
( \(sim.mpi\) {) p n
0 T (      MPI::COMM_WORLD.Bcast\(&conf.current\(\).posV\(0\)\(0\), conf.current\(\).posV.size) N
0 T (\(\) * 3, MPI::DOUBLE, 0\);) N
0 T (      MPI::COMM_WORLD.Bcast\(&minfield, 1, MPI::DOUBLE, 0\);) N
0 T (    }) N
(1750) # () S
(#endif) K n
0 T () S
(    DEBUG\(11, ") p
(\\trank: ) str
(" << rank << ") p
( minfield: ) str
(" << minfield << ") p
( iteration round: ) str
(" << turni) p n
0 T (\);) N
0 T (  }) N
0 T (  DEBUG\(5, ") S
(electric field iterations: ) str
(" << turni\);) p n
0 T (}) N
(1755) # () N
0 T () S
(void) k
( interaction::Nonbonded_Outerloop) p n
0 T (::ls_real_outerloop\(topology::Topology & topo,) N
0 T (        configuration::Configuration & conf,) N
0 T (        simulation::Simulation & sim,) N
(1760) # (        Pairlist ) S
(const) K
( & pairlist_solute,) p n
0 T (        Pairlist ) S
(const) K
( & pairlist_solvent,) p n
0 T (        Storage & storage, ) S
(int) k
( rank, ) p
(int) k
( size\) {) p n
0 T (  SPLIT_INNERLOOP\(_ls_real_outerloop, topo, conf, sim,) N
0 T (          pairlist_solute, pairlist_solvent, storage, rank, size\);) N
(1765) # (}) N
0 T () N
0 T () S
(template) K
(<) p
(typename) k
( t_interaction_spec>) p n
0 T () S
(void) k
( interaction::Nonbonded_Outerloop) p n
0 T (::_ls_real_outerloop\(topology::Topology & topo,) N
(1770) # (        configuration::Configuration & conf,) N
0 T (        simulation::Simulation & sim,) N
0 T (        Pairlist ) S
(const) K
( & pairlist_solute,) p n
0 T (        Pairlist ) S
(const) K
( & pairlist_solvent,) p n
0 T (        Storage & storage, ) S
(int) k
( rank, ) p
(int) k
( size\) {) p n
(1775) # () N
0 T (  DEBUG\(7, ") S
(\\tcalculate LS real space interactions) str
("\);) p n
0 T () N
0 T (  math::Periodicity<t_interaction_spec::boundary_type> periodicity\(conf.current\() N
0 T (\).box\);) N
0 T (  Nonbonded_Innerloop<t_interaction_spec> innerloop\(m_param\);) N
(1780) # (  innerloop.init\(sim\);) N
0 T () N
0 T (  ) S
(/*) c n
0 T (    variables for a OMP parallelizable loop.) N
0 T (    outer index has to be integer...) N
(1785) # (   */) N
0 T () S
(  std::vector<) p
(unsigned) k
( ) p
(int) k
(>::const_iterator j_it, j_to;) p n
(nonbonded_outerloop.cc) (Page 26/40) (Dec 06, 18 14:53) title
border
grestore
(Printed by Patrick Bleiziffer) rhead
(nonbonded_outerloop.cc) (13/20) (Thursday December 06, 2018) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (27-28) 14
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 2.965278 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
0 T (  topology::excl_cont_t::value_type::const_iterator ex_it, ex_to;) p n
0 T () N
0 T (  ) S
(unsigned) k
( ) p
(int) k
( size_i = ) p
(unsigned) k
(\(pairlist_solute.size\(\)\);) p n
(1790) # (  DEBUG\(10, ") S
(ls_real outerloop pairlist size ) str
(" << size_i\);) p n
0 T () N
0 T (  ) S
(unsigned) k
( ) p
(int) k
( end = topo.num_solute_atoms\(\);) p n
0 T () N
0 T (  ) S
(unsigned) k
( ) p
(int) k
( i;) p n
(1795) # (  ) S
(for) K
( \(i = 0; i < end; i++\) {) p n
0 T (    ) S
(for) K
( \(j_it = pairlist_solute[i].begin\(\),) p n
0 T (            j_to = pairlist_solute[i].end\(\);) N
0 T (            j_it != j_to;) N
0 T (            ++j_it\) {) N
(1800) # () N
0 T (      DEBUG\(10, ") S
(\\tnonbonded_interaction: i ) str
(" << i << ") p
( j ) str
(" << *j_it\);) p n
0 T () N
0 T (      ) S
(// shortrange, therefore store in simulation.system\(\)) c n
0 T () S
(      innerloop.lj_ls_real_innerloop\(topo, conf, i, *j_it, storage, periodicity\)) p n
0 T (;) N
(1805) # (    }) N
0 T (  }) N
0 T () N
0 T (  ) S
(for) K
( \(; i < size_i; i++\) {) p n
0 T (    ) S
(for) K
( \(j_it = pairlist_solvent[i].begin\(\),) p n
(1810) # (            j_to = pairlist_solvent[i].end\(\);) N
0 T (            j_it != j_to;) N
0 T (            ++j_it\) {) N
0 T () N
0 T (      DEBUG\(10, ") S
(\\tsolvent_nonbonded_interaction: i ) str
(" << i << ") p
( j ) str
(" << *j_it\);) p n
(1815) # () N
0 T (      innerloop.lj_ls_real_innerloop\(topo, conf, i, *j_it, storage, periodicity\)) N
0 T (;) N
0 T (    }) N
0 T (  }) N
0 T () N
(1820) # (  ) S
(// loop over all exclusions as they have reduced LS interactions in real space) c n
0 T () S
(  ) p
(// parrallelization using stride. Then MPI should work) c n
0 T () S
(  DEBUG\(9, ") p
(U_eta due to excluded solute pairs...) str
("\);) p n
0 T (  ) S
(const) K
( ) p
(unsigned) k
( ) p
(int) k
( size_int = topo.num_solute_atoms\(\);) p n
0 T (  ) S
(for) K
( \() p
(unsigned) k
( ) p
(int) k
( i = rank; i < size_int; i += size\) {) p n
(1825) # (    ) S
(for) K
( \(ex_it = topo.exclusion\(i\).begin\(\),) p n
0 T (            ex_to = topo.exclusion\(i\).end\(\);) N
0 T (            ex_it != ex_to;) N
0 T (            ++ex_it\) {) N
0 T () N
(1830) # (      DEBUG\(10, ") S
(\\texcluded_nonbonded_interaction: i ) str
(" << i << ") p
( j ) str
(" << *ex_it\);) p n
0 T (      innerloop.ls_real_excluded_innerloop\(topo, conf, i, *ex_it, storage, perio) N
0 T (dicity\);) N
0 T (    }) N
0 T (  }) N
0 T (  DEBUG\(9, ") S
(U_eta due to excluded solvent pairs...) str
("\);) p n
(1835) # (  ) S
(const) K
( ) p
(unsigned) k
( ) p
(int) k
( num_cg = topo.num_chargegroups\(\);) p n
0 T (  ) S
(for) K
( \() p
(unsigned) k
( ) p
(int) k
( i = topo.num_solute_chargegroups\(\) + rank; i < num_cg; i += ) p n
0 T (size\) {) N
0 T (    ) S
(for) K
( \() p
(int) k
( a1 = topo.chargegroup\(i\),) p n
0 T (            a_to = topo.chargegroup\(i + 1\);) N
0 T (            a1 < a_to; ++a1\) {) N
(1840) # (      ) S
(for) K
( \() p
(int) k
( a2 = a1 + 1; a2 < a_to; ++a2\) {) p n
0 T (        DEBUG\(10, ") S
(\\texcluded_nonbonded_interaction: i ) str
(" << a1 << ") p
( j ) str
(" << a2\);) p n
0 T (        innerloop.ls_real_excluded_innerloop\(topo, conf, a1, a2, storage, period) N
0 T (icity\);) N
0 T (      }) N
0 T (    }) N
(1845) # (  }) N
0 T () N
0 T (}) N
0 T () N
0 T () S
(void) k
( interaction::Nonbonded_Outerloop) p n
(1850) # (::ls_ewald_kspace_outerloop\(topology::Topology & topo,) N
0 T (        configuration::Configuration & conf,) N
0 T (        simulation::Simulation & sim,) N
0 T (        Storage & storage, ) S
(int) k
( rank, ) p
(int) k
( size\) {) p n
0 T (  SPLIT_INNERLOOP\(_ls_ewald_kspace_outerloop, topo, conf, sim,) N
(nonbonded_outerloop.cc) (Page 27/40) (Dec 06, 18 14:53) title
border
/v 1 store
/x0 x v get 2.965278 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(1855) # (          storage, rank, size\);) p n
0 T (}) N
0 T () N
0 T () S
(template) K
(<) p
(typename) k
( t_interaction_spec>) p n
0 T () S
(void) k
( interaction::Nonbonded_Outerloop) p n
(1860) # (::_ls_ewald_kspace_outerloop\(topology::Topology & topo,) N
0 T (        configuration::Configuration & conf,) N
0 T (        simulation::Simulation & sim,) N
0 T (        Storage & storage, ) S
(int) k
( rank, ) p
(int) k
( size\) {) p n
0 T (  DEBUG\(7, ") S
(\\tcalculate interactions in k-space \(Ewald\)) str
("\);) p n
(1865) # () N
0 T (  math::Periodicity<t_interaction_spec::boundary_type> periodicity\(conf.current\() N
0 T (\).box\);) N
0 T (  Nonbonded_Innerloop<t_interaction_spec> innerloop\(m_param\);) N
0 T (  innerloop.init\(sim\);) N
0 T () N
(1870) # (  ) S
(const) K
( ) p
(double) k
( volume = math::volume\(conf.current\(\).box, t_interaction_spec::bou) p n
0 T (ndary_type\);) N
0 T (  ) S
(const) K
( ) p
(double) k
( eps_volume_i = math::eps0_i / volume;) p n
0 T () N
0 T (  DEBUG\(10, ") S
(\\t\\teps_volume_i: ) str
(" << eps_volume_i\);) p n
0 T (  ) S
(const) K
( std::vector<configuration::KSpace_Element> & kspace = conf.lattice_sum\(\)) p n
0 T (.kspace;) N
(1875) # (  std::vector<configuration::KSpace_Element>::const_iterator it = kspace.begin\(\)) N
0 T (,) N
0 T (          to = kspace.end\(\);) N
0 T () N
0 T (  ) S
(const) K
( ) p
(unsigned) k
( ) p
(int) k
( num_atoms = topo.num_atoms\(\);) p n
0 T (  ) S
(// a copy of the current positions because of gathering) c n
(1880) # () S
(  math::VArray r = conf.current\(\).pos;) p n
0 T () N
0 T (  ) S
(// storage for the k space energy) c n
0 T () S
(  ) p
(double) k
( energy = 0.0;) p n
0 T (  ) S
(// and force) c n
(1885) # () S
(  math::VArray f\(num_atoms\);) p n
0 T (  f = 0.0;) N
0 T () N
0 T (  ) S
(// Do we have to gather here ?) c n
0 T () S
(  ) p
(for) K
( \() p
(unsigned) k
( ) p
(int) k
( i = 0; i < num_atoms; ++i\) {) p n
(1890) # (    periodicity.put_into_positive_box\(r\(i\)\);) N
0 T () N
0 T (    DEBUG\(11, ") S
(r\() str
(" << i << ") p
(\) in box: ) str
(" << math::v2s\(r\(i\)\)\);) p n
0 T (  }) N
0 T () N
(1895) # (  ) S
(// cache for sin\(k . r\) and cos\(k .  r\) terms) c n
0 T () S
(  math::SArray sin_kr\(num_atoms, 0.0\), cos_kr\(num_atoms, 0.0\);) p n
0 T () N
0 T (  ) S
(// on fly we can calculate the methodology dependent A2 term) c n
0 T () S
(  ) p
(double) k
( a2_tilde = 0.0;) p n
(1900) # () N
0 T (  ) S
(// virial stuff) c n
0 T () S
(  ) p
(const) K
( ) p
(double) k
( do_virial = sim.param\(\).pcouple.virial != math::no_virial;) p n
0 T (  math::SymmetricMatrix virial\(0.0\);) N
0 T (  math::SymmetricMatrix sum_gammahat\(0.0\);) N
(1905) # () N
0 T (  ) S
(// loop over k space) c n
0 T () S
(  ) p
(for) K
( \(; it != to; ++it\) {) p n
0 T (    DEBUG\(12, ") S
(k: ) str
(" << math::v2s\(it->k\)\);) p n
0 T (    ) S
(double) k
( C_k = 0.0;) p n
(1910) # (    ) S
(double) k
( S_k = 0.0;) p n
0 T (    ) S
(// loop over atoms, calculate C/S_k and cache the sins and coses) c n
0 T () S
(    ) p
(for) K
( \() p
(unsigned) k
( ) p
(int) k
( i = 0; i < num_atoms; ++i\) {) p n
0 T (      ) S
(const) K
( ) p
(double) k
( r_dot_k = math::dot\(it->k, r\(i\)\);) p n
0 T (      sin_kr\(i\) = sin\(r_dot_k\);) N
(1915) # (      cos_kr\(i\) = cos\(r_dot_k\);) N
0 T (      C_k += topo.charge\(i\) * cos_kr\(i\);) N
0 T (      S_k += topo.charge\(i\) * sin_kr\(i\);) N
0 T (    }) N
0 T () N
(1920) # (    ) S
(// calculate the force component from k) c n
0 T () S
(    ) p
(for) K
( \() p
(unsigned) k
( ) p
(int) k
( i = 0; i < num_atoms; ++i\) {) p n
0 T (      f\(i\) += it->k * \(it->k2i_gammahat * \(C_k * sin_kr\(i\) - S_k * cos_kr\(i\)\)\);) N
0 T (    }) N
(nonbonded_outerloop.cc) (Page 28/40) (Dec 06, 18 14:53) title
border
grestore
(Printed by Patrick Bleiziffer) rhead
(nonbonded_outerloop.cc) (14/20) (Thursday December 06, 2018) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (29-30) 15
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 2.965278 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
0 T (    ) p
(// and the energy component from k) c n
(1925) # () S
(    ) p
(const) K
( ) p
(double) k
( ewald_factor = C_k * C_k + S_k * S_k;) p n
0 T (    energy += it->k2i_gammahat * ewald_factor;) N
0 T (    ) S
(// add to the A2 term) c n
0 T () S
(    a2_tilde += it->k2i_gammahat;) p n
0 T (    ) S
(// do the virial) c n
(1930) # () S
(    ) p
(if) K
( \(do_virial\) {) p n
0 T (      ) S
(const) K
( ) p
(double) k
( isotropic_factor =) p n
0 T (              \(it->ak_gammahat_prime - 2.0 * it->fourier_coefficient\) *) N
0 T (              \(it->k2i * it->k2i\);) N
0 T (      ) S
(const) K
( math::SymmetricMatrix term\(math::symmetric_tensor_product\(isotropic_) p n
0 T (factor * it->k, it->k\)\);) N
(1935) # (      sum_gammahat += term;) N
0 T (      virial += ewald_factor * term;) N
0 T (      virial.add_to_diagonal\(ewald_factor * it->k2i_gammahat\);) N
0 T (    } ) S
(// if virial) c n
0 T () S
(  } ) p
(// for k space) c n
(1940) # () N
0 T () S
(  ) p
(// loop again over atoms and store force) c n
0 T () S
(  ) p
(for) K
( \() p
(unsigned) k
( ) p
(int) k
( i = 0; i < num_atoms; ++i\) {) p n
0 T (    ) S
(// calculate the force) c n
0 T () S
(    f\(i\) *= topo.charge\(i\) * eps_volume_i;) p n
(1945) # (    DEBUG\(12, ") S
(force f\() str
(" << i << ") p
(\): ) str
(" << math::v2s\(f\(i\)\)\);) p n
0 T (    ) S
(// add the force) c n
0 T () S
(    storage.force\(i\) += f\(i\);) p n
0 T (  }) N
0 T () N
(1950) # (  ) S
(// scale the energy) c n
0 T () S
(  energy *= eps_volume_i * 0.5;) p n
0 T (  DEBUG\(8, ") S
(Ewald k-space energy: ) str
(" << energy\);) p n
0 T (  storage.energies.ls_kspace_total = energy;) N
0 T () N
(1955) # (  ) S
(// add the A2 sum before it is scaled) c n
0 T () S
(  ) p
(if) K
( \(do_virial\)) p n
0 T (    sum_gammahat.add_to_diagonal\(a2_tilde\);) N
0 T () N
0 T (  ) S
(// scale the a2 term) c n
(1960) # () S
(  a2_tilde *= 4.0 * math::Pi / volume;) p n
0 T (  conf.lattice_sum\(\).a2_tilde = a2_tilde;) N
0 T () N
0 T (  ) S
(// and the virial) c n
0 T () S
(  ) p
(if) K
( \(do_virial\) {) p n
(1965) # (    virial *= -0.25 * eps_volume_i;) N
0 T (    DEBUG\(6, ") S
(Ewald k-space virial:\\n) str
(" << math::m2s\(virial\)\);) p n
0 T () S
(// !!! multiply by -2 because of multiplication with -0.5 in pressure calculatio) c n
0 T (n) N
0 T () S
(   ) p
(// storage.virial_tensor += virial;) c n
0 T () S
(    storage.virial_tensor += \(-2.0 * virial\);) p n
(1970) # () N
0 T (    conf.lattice_sum\(\).a2_tilde_derivative = \(4.0 * math::Pi / volume\) * sum_gam) N
0 T (mahat;) N
0 T (  }) N
0 T () N
0 T (}) N
(1975) # () N
0 T () S
(void) k
( interaction::Nonbonded_Outerloop) p n
0 T (::ls_p3m_kspace_outerloop\(topology::Topology & topo,) N
0 T (        configuration::Configuration & conf,) N
0 T (        simulation::Simulation & sim,) N
(1980) # (        Storage & storage, ) S
(int) k
( rank, ) p
(int) k
( size,) p n
0 T (        util::Algorithm_Timer & timer,) N
0 T (        ) S
(bool) k
( & is_ok\) {) p n
0 T (  SPLIT_INNERLOOP\(_ls_p3m_kspace_outerloop, topo, conf, sim,) N
0 T (          storage, rank, size, timer, is_ok\);) N
(1985) # (}) N
0 T () N
0 T () S
(template) K
(<) p
(typename) k
( t_interaction_spec>) p n
0 T () S
(void) k
( interaction::Nonbonded_Outerloop) p n
0 T (::_ls_p3m_kspace_outerloop\(topology::Topology & topo,) N
(1990) # (        configuration::Configuration & conf,) N
0 T (        simulation::Simulation & sim,) N
0 T (        Storage & storage, ) S
(int) k
( rank, ) p
(int) k
( size,) p n
0 T (        util::Algorithm_Timer & timer,) N
(nonbonded_outerloop.cc) (Page 29/40) (Dec 06, 18 14:53) title
border
/v 1 store
/x0 x v get 2.965278 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
0 T (        ) p
(bool) k
( & is_ok\) {) p n
(1995) # (  DEBUG\(7, ") S
(\\tcalculate interactions in k-space \(P3M\)) str
("\);) p n
0 T () N
0 T (  math::Periodicity<t_interaction_spec::boundary_type> periodicity\(conf.current\() N
0 T (\).box\);) N
0 T (  math::VArray r = conf.current\(\).pos;) N
0 T (  ) S
(// Do we have to gather here ?) c n
(2000) # () S
(  ) p
(const) K
( ) p
(unsigned) k
( ) p
(int) k
( num_atoms = topo.num_atoms\(\);) p n
0 T (  ) S
(for) K
( \() p
(unsigned) k
( ) p
(int) k
( i = 0; i < num_atoms; ++i\) {) p n
0 T (    periodicity.put_into_positive_box\(r\(i\)\);) N
0 T () N
0 T (    DEBUG\(11, ") S
(r\() str
(" << i << ") p
(\) in box: ) str
(" << math::v2s\(r\(i\)\)\);) p n
(2005) # (  }) N
0 T () N
0 T (  ) S
(if) K
( \(sim.openmp && rank != 0\) {) p n
0 T (    ) S
(// for openmp this is single threaded) c n
0 T () S
(    ) p
(return) K
(;) p n
(2010) # (  }) N
0 T (  ) N
0 T (  ) S
(// decompose into domains) c n
0 T () S
(  ) p
(if) K
( \(sim.mpi\)) p n
0 T (    interaction::Lattice_Sum::decompose_into_domains<configuration::ParallelMesh) N
0 T ( > \(topo, conf, sim, storage.domain, r, size\);) N
(2015) # (  ) S
(else) K n
0 T () S
(    interaction::Lattice_Sum::decompose_into_domains<configuration::Mesh > \(topo) p n
0 T (, conf, sim, storage.domain, r, size\);) N
0 T () N
0 T (  DEBUG\(10, ") S
(size domain\() str
(" << rank << ") p
(\): ) str
(" << storage.domain.size\(\)\);) p n
0 T () N
(2020) # (  ) S
(// always calculate at the beginning or read it from file.) c n
0 T () S
(  ) p
(if) K
( \(sim.steps\(\) == 0 && !sim.param\(\).nonbonded.influence_function_read\) {) p n
0 T (    DEBUG\(10, ") S
(\\t calculating influence function) str
("\);) p n
0 T (    ) S
(if) K
( \(rank == 0\)) p n
0 T (      timer.start\(") S
(P3M: influence function) str
("\);) p n
(2025) # (    ) S
(if) K
( \(sim.mpi\)) p n
0 T (      conf.lattice_sum\(\).influence_function.) S
(template) K
( calculate< configuration::P) p n
0 T (arallelMesh > \(topo, conf, sim\);) N
0 T (    ) S
(else) K n
0 T () S
(      conf.lattice_sum\(\).influence_function.) p
(template) K
( calculate< configuration::M) p n
0 T (esh > \(topo, conf, sim\);) N
0 T () N
(2030) # (    ) S
(const) K
( ) p
(double) k
( new_rms_force_error = conf.lattice_sum\(\).influence_function.rms) p n
0 T (_force_error\(\);) N
0 T (    DEBUG\(10, ") S
(\\testimated force error: ) str
(" << new_rms_force_error\);) p n
0 T () N
0 T (    ) S
(if) K
( \(rank == 0\)) p n
0 T (      timer.stop\(") S
(P3M: influence function) str
("\);) p n
(2035) # () N
0 T (    ) S
(if) K
( \(new_rms_force_error > sim.param\(\).nonbonded.influence_function_rms_force) p n
0 T (_error\) {) N
0 T (      io::messages.add\(") S
(P3M: RMS force error is still too big after reevaluation ) str
(") p n
0 T (              ") S
(of the influence function. Increase the number of grid points, ) str
(") p n
0 T (              ") S
(the rms force error threshold, or the charge width parameter.) str
(",) p n
(2040) # (              ") S
(P3M) str
(", io::message::error\);) p n
0 T () S
(// !!! this does not lead to a crash of the simulation, but it should crash) c n
0 T (// set a bool which is checked in nonbonded_set ) N
0 T () S
(     is_ok = ) p
(false) k
(;) p n
0 T (      ) S
(return) K
(;) p n
(2045) # (    }) N
0 T (  }) N
0 T () N
0 T (  ) S
(// give the current box to the influence function for correction) c n
0 T () S
(  ) p
(// this has to be done AFTER the influence function is calculated) c n
(2050) # () S
(  conf.lattice_sum\(\).influence_function.setBox\(conf.current\(\).box\);) p n
0 T () N
0 T (  ) S
(// check whether we have to update the influence function) c n
0 T () S
(  ) p
(if) K
( \(sim.steps\(\) && sim.param\(\).nonbonded.accuracy_evaluation &&) p n
0 T (          sim.steps\(\) % sim.param\(\).nonbonded.accuracy_evaluation == 0\) {) N
(2055) # (    ) S
(if) K
( \(rank == 0\)) p n
0 T (      timer.start\(") S
(P3M: accuracy evaluation) str
("\);) p n
0 T (    ) S
(if) K
( \(sim.mpi\)) p n
0 T (      conf.lattice_sum\(\).influence_function.) S
(template) K
( evaluate_quality<configurat) p n
0 T (ion::ParallelMesh > \(topo, conf, sim\);) N
(nonbonded_outerloop.cc) (Page 30/40) (Dec 06, 18 14:53) title
border
grestore
(Printed by Patrick Bleiziffer) rhead
(nonbonded_outerloop.cc) (15/20) (Thursday December 06, 2018) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (31-32) 16
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 2.965278 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
0 T (    ) p
(else) K n
(2060) # () S
(      conf.lattice_sum\(\).influence_function.) p
(template) K
( evaluate_quality<configurat) p n
0 T (ion::Mesh > \(topo, conf, sim\);) N
0 T (    ) S
(// number of charges is set to number of atoms as in promd...) c n
0 T () S
(    ) p
(// see MD02.10 eq. C7) c n
0 T () S
(    ) p
(const) K
( ) p
(double) k
( rms_force_error = conf.lattice_sum\(\).influence_function.rms_for) p n
0 T (ce_error\(\);) N
0 T (    ) S
(if) K
( \(rank == 0\)) p n
(2065) # (      timer.stop\(") S
(P3M: accuracy evaluation) str
("\);) p n
0 T () N
0 T (    ) S
(if) K
( \(rms_force_error > sim.param\(\).nonbonded.influence_function_rms_force_err) p n
0 T (or\) {) N
0 T (      ) S
(// recalculate the influence function) c n
0 T () S
(      DEBUG\(10, ") p
(\\t calculating influence function) str
("\);) p n
(2070) # (      ) S
(if) K
( \(rank == 0\)) p n
0 T (        timer.start\(") S
(P3M: influence function) str
("\);) p n
0 T (      ) S
(if) K
( \(sim.mpi\)) p n
0 T (        conf.lattice_sum\(\).influence_function.) S
(template) K
( calculate<configuration::) p n
0 T (ParallelMesh > \(topo, conf, sim\);) N
0 T (      ) S
(else) K n
(2075) # () S
(        conf.lattice_sum\(\).influence_function.) p
(template) K
( calculate<configuration::) p n
0 T (Mesh > \(topo, conf, sim\);) N
0 T () N
0 T (      ) S
(const) K
( ) p
(double) k
( new_rms_force_error = conf.lattice_sum\(\).influence_function.r) p n
0 T (ms_force_error\(\);) N
0 T (      ) S
(if) K
( \(rank == 0\)) p n
0 T (        timer.stop\(") S
(P3M: influence function) str
("\);) p n
(2080) # () N
0 T (      ) S
(if) K
( \(new_rms_force_error > sim.param\(\).nonbonded.influence_function_rms_for) p n
0 T (ce_error\) {) N
0 T (        io::messages.add\(") S
(P3M: RMS force error is still too big after reevaluation ) str
(") p n
0 T (                ") S
(of the influence function. Increase the number of grid points, ) str
(") p n
0 T (                ") S
(the rms force error threshold, or the charge width parameter.) str
(",) p n
(2085) # (                ") S
(P3M) str
(", io::message::error\);) p n
0 T () S
(// !!! this does not lead to a crash of the simulation, but it should crash) c n
0 T (// set a bool which is checked in nonbonded_set ) N
0 T () S
(     is_ok = ) p
(false) k
(;) p n
0 T (        ) S
(return) K
(;) p n
(2090) # (      }) N
0 T (    } ) S
(// if force error) c n
0 T () S
(  } ) p
(// if update influence function) c n
0 T () N
0 T () S
(  ) p
(// check whether we need to calculate the A2~ term via P3M.) c n
(2095) # () S
(  ) p
(// check whether we have to calculate it at all in this step) c n
0 T () S
(  ) p
(bool) k
( calculate_lattice_sum_corrections =) p n
0 T (          sim.param\(\).pcouple.scale != math::pcouple_off || ) S
(// NPT - every step) c n
0 T () S
(          !sim.steps\(\) || ) p
(// at the beginning of the simulation) c n
0 T () S
(          \(sim.param\(\).print.stepblock != 0 && sim.steps\(\) % abs\(sim.param\(\).pri) p n
0 T (nt.stepblock\) == 0\) ||   ) S
(// energy output req.) c n
(2100) # () S
(          \(sim.param\(\).write.energy != 0 && sim.steps\(\) % abs\(sim.param\(\).write.) p n
0 T (energy\) == 0\); ) S
(// energy output req. !!!) c n
0 T () S
(  ) p
(const) K
( ) p
(bool) k
( do_a2t =) p n
0 T (          sim.param\(\).nonbonded.ls_calculate_a2 == simulation::ls_a2t_exact ||) N
0 T (          sim.param\(\).nonbonded.ls_calculate_a2 == simulation::ls_a2t_exact_a2_n) N
0 T (umerical ||) N
0 T (          sim.param\(\).nonbonded.ls_calculate_a2 == simulation::ls_a2t_ave_a2_num) N
0 T (erical;) N
(2105) # () N
0 T (  ) S
(// calculate the A2~ self term via P3M.) c n
0 T () S
(  ) p
(if) K
( \(do_a2t && calculate_lattice_sum_corrections\) {) p n
0 T (    DEBUG\(10, ") S
(\\tstarting to assign squared charge to grid ... ) str
("\);) p n
0 T (    ) S
(if) K
( \(rank == 0\)) p n
(2110) # (      timer.start\(") S
(P3M: self term) str
("\);) p n
0 T () N
0 T (    ) S
(if) K
( \(sim.param\(\).nonbonded.ls_calculate_a2 != simulation::ls_a2t_ave_a2_numer) p n
0 T (ical\) {) N
0 T (      ) S
(// calculate the real A2~ term \(not averaged\)) c n
0 T () S
(      ) p
(if) K
( \(sim.mpi\)) p n
(2115) # (        interaction::Lattice_Sum::calculate_squared_charge_grid<configuration::P) N
0 T (arallelMesh > \(topo, conf, sim, storage.domain, r\);) N
0 T (      ) S
(else) K n
0 T () S
(        interaction::Lattice_Sum::calculate_squared_charge_grid<configuration::M) p n
0 T (esh > \(topo, conf, sim, storage.domain, r\);) N
(nonbonded_outerloop.cc) (Page 31/40) (Dec 06, 18 14:53) title
border
/v 1 store
/x0 x v get 2.965278 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
0 T (    } ) p
(else) K
( {) p n
0 T (      ) S
(// calculate the averaged A2~ term) c n
(2120) # () S
(      ) p
(if) K
( \(sim.mpi\)) p n
0 T (        interaction::Lattice_Sum::calculate_averaged_squared_charge_grid<configu) N
0 T (ration::ParallelMesh > \(topo, conf, sim, storage.domain\);) N
0 T (      ) S
(else) K n
0 T () S
(        interaction::Lattice_Sum::calculate_averaged_squared_charge_grid<configu) p n
0 T (ration::Mesh > \(topo, conf, sim, storage.domain\);) N
0 T (    }) N
(2125) # (    DEBUG\(10, ") S
(\\tstarting fft of the squared charge) str
("\);) p n
0 T (    ) S
(// FFT the charge density grid) c n
0 T () S
(    configuration::Mesh & squared_charge = *conf.lattice_sum\(\).squared_charge;) p n
0 T (    squared_charge.fft\(configuration::Mesh::fft_forward\);) N
0 T () N
(2130) # (    DEBUG\(10, ") S
(\\tcalculation of self term via P3M.) str
("\);) p n
0 T (    ) S
(if) K
( \(sim.mpi\) {) p n
0 T (      interaction::Lattice_Sum::calculate_p3m_selfterm<configuration::ParallelMe) N
0 T (sh > \(topo, conf, sim\);) N
0 T (    } ) S
(else) K
( {) p n
0 T (      interaction::Lattice_Sum::calculate_p3m_selfterm<configuration::Mesh > \(to) N
0 T (po, conf, sim\);) N
(2135) # (    }) N
0 T () N
0 T (    ) S
(if) K
( \(rank == 0\)) p n
0 T (      timer.stop\(") S
(P3M: self term) str
("\);) p n
0 T (  }) N
(2140) # (  ) N
0 T (  ) N
0 T (  ) S
(if) K
( \(rank == 0\)) p n
0 T (    timer.start\(") S
(P3M: energy & force) str
("\);) p n
0 T () N
(2145) # (  DEBUG\(10, ") S
(\\t done with influence function, starting to assign charge density to grid ... ) str
("\);) p n
0 T (  ) S
(if) K
( \(sim.mpi\)) p n
0 T (    interaction::Lattice_Sum::calculate_charge_density<configuration::ParallelMe) N
0 T (sh > \(topo, conf, sim, storage.domain, r\);) N
0 T (  ) S
(else) K n
0 T () S
(    interaction::Lattice_Sum::calculate_charge_density<configuration::Mesh > \(to) p n
0 T (po, conf, sim, storage.domain, r\);) N
(2150) # () N
0 T () N
0 T (  DEBUG\(10, ") S
(\\t assigned charge density to grid, starting fft of charge density) str
("\);) p n
0 T (  ) S
(// FFT the charge density grid) c n
0 T () S
(  configuration::Mesh & charge_density = *conf.lattice_sum\(\).charge_density;) p n
(2155) # (  charge_density.fft\(configuration::Mesh::fft_forward\);) N
0 T (  DEBUG\(10, ") S
(\\t done with fft! Starting to calculate the energy ...) str
("\);) p n
0 T () N
0 T (  ) S
(if) K
( \(sim.mpi\) {) p n
0 T (    interaction::Lattice_Sum::calculate_potential_and_energy<configuration::Para) N
0 T (llelMesh > \(topo, conf, sim, storage\);) N
(2160) # (  } ) S
(else) K
( {) p n
0 T (    interaction::Lattice_Sum::calculate_potential_and_energy<configuration::Mesh) N
0 T ( > \(topo, conf, sim, storage\);) N
0 T (  }) N
0 T (  DEBUG\(10, ") S
(\\t done with calculation of elec. potential and energy, calculating electric field...) str
("\);) p n
0 T (  ) S
(if) K
( \(sim.mpi\) {) p n
(2165) # (    interaction::Lattice_Sum::calculate_electric_field<configuration::ParallelMe) N
0 T (sh > \(topo, conf, sim\);) N
0 T (  } ) S
(else) K
( {) p n
0 T (    interaction::Lattice_Sum::calculate_electric_field<configuration::Mesh > \(to) N
0 T (po, conf, sim\);) N
0 T (  }) N
0 T (  DEBUG\(10, ") S
(\\t done with electric field calculation, calculating forces) str
("\);) p n
(2170) # (  ) S
(if) K
( \(sim.mpi\) {) p n
0 T (    interaction::Lattice_Sum::calculate_force<configuration::ParallelMesh > \(top) N
0 T (o, conf, sim, storage, r\);) N
0 T (  } ) S
(else) K
( {) p n
0 T (    interaction::Lattice_Sum::calculate_force<configuration::Mesh > \(topo, conf,) N
0 T ( sim, storage, r\);) N
0 T (  }) N
(2175) # () N
0 T (  ) S
(if) K
( \(rank == 0\)) p n
0 T (    timer.stop\(") S
(P3M: energy & force) str
("\);) p n
0 T (  DEBUG\(7, ") S
(\\tdone with calculating interactions in k-space \(P3M\)) str
("\);) p n
(nonbonded_outerloop.cc) (Page 32/40) (Dec 06, 18 14:53) title
border
grestore
(Printed by Patrick Bleiziffer) rhead
(nonbonded_outerloop.cc) (16/20) (Thursday December 06, 2018) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (33-34) 17
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 2.965278 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
0 T (}) p n
(2180) # () N
0 T () S
(void) k
( interaction::Nonbonded_Outerloop) p n
0 T (::ls_self_outerloop\(topology::Topology & topo,) N
0 T (        configuration::Configuration & conf,) N
0 T (        simulation::Simulation & sim,) N
(2185) # (        Storage & storage, ) S
(int) k
( rank, ) p
(int) k
( size\) {) p n
0 T (  DEBUG\(8, ") S
(\\telectrostatic self energy and virial) str
("\);) p n
0 T () S
(#ifdef) K
( OMP) p n
0 T (  ) S
(if) K
( \(rank != 0\) ) p
(return) K
(;) p n
0 T (  size = 1;) N
(2190) # () S
(#endif) K n
0 T () N
0 T () S
(  ) p
(double) k
( a1 = 0.0, a3 = 0.0;) p n
0 T (  ) S
(double) k
( & a2_tilde = conf.lattice_sum\(\).a2_tilde;) p n
0 T (  ) S
(double) k
( a2;) p n
(2195) # () N
0 T (  ) S
(const) K
( ) p
(double) k
( st2 = topo.sum_squared_charges\(\);) p n
0 T (  ) S
(const) K
( ) p
(double) k
( s2 = topo.squared_sum_charges\(\);) p n
0 T () N
0 T (  ) S
(const) K
( ) p
(bool) k
( do_virial = sim.param\(\).pcouple.virial != math::no_virial;) p n
(2200) # () N
0 T (  ) S
(const) K
( ) p
(int) k
( shape = sim.param\(\).nonbonded.ls_charge_shape;) p n
0 T (  ) S
(// see MD05.32 Table 6) c n
0 T () S
(  ) p
(switch) K
( \(shape\) {) p n
0 T (    ) S
(case) K
( -1:) p n
(2205) # (      a1 = 1.0;) N
0 T (      a3 = 2.0 * 1.0 / sqrt\(math::Pi\);) N
0 T (      ) S
(break) K
(;) p n
0 T (    ) S
(case) K
( 0:) p n
0 T (      a1 = 2.0 / 5.0;) N
(2210) # (      a3 = 3.0 / 2.0;) N
0 T (      ) S
(break) K
(;) p n
0 T (    ) S
(case) K
( 1:) p n
0 T (      a1 = 4.0 / 15.0;) N
0 T (      a3 = 2.0;) N
(2215) # (      ) S
(break) K
(;) p n
0 T (    ) S
(case) K
( 2:) p n
0 T (      a1 = 4.0 / 21.0;) N
0 T (      a3 = 5.0 / 2.0;) N
0 T (      ) S
(break) K
(;) p n
(2220) # (    ) S
(case) K
( 3:) p n
0 T (      a1 = 3.0 / 14.0;) N
0 T (      a3 = 9.0 / 4.0;) N
0 T (      ) S
(break) K
(;) p n
0 T (    ) S
(case) K
( 4:) p n
(2225) # (      a1 = 1.0 / 6.0;) N
0 T (      a3 = 21.0 / 8.0;) N
0 T (      ) S
(break) K
(;) p n
0 T (    ) S
(case) K
( 5:) p n
0 T (      a1 = 2.0 / 15.0;) N
(2230) # (      a3 = 3.0;) N
0 T (      ) S
(break) K
(;) p n
0 T (    ) S
(case) K
( 6:) p n
0 T (      a1 = 8.0 / 55.0;) N
0 T (      a3 = 45.0 / 16.0;) N
(2235) # (      ) S
(break) K
(;) p n
0 T (    ) S
(case) K
( 7:) p n
0 T (      a1 = 4.0 / 33.0;) N
0 T (      a3 = 25.0 / 8.0;) N
0 T (      ) S
(break) K
(;) p n
(2240) # (    ) S
(case) K
( 8:) p n
0 T (      a1 = 4.0 / 39.0;) N
0 T (      a3 = 55.0 / 16.0;) N
0 T (      ) S
(break) K
(;) p n
0 T (    ) S
(case) K
( 9:) p n
(2245) # (      a1 = 10.0 / 91.0;) N
0 T (      a3 = 105.0 / 32.0;) N
0 T (      ) S
(break) K
(;) p n
0 T (    ) S
(case) K
( 10:) p n
0 T (      a1 = 2.0 / 21.0;) N
(2250) # (      a3 = 455.0 / 128.0;) N
0 T (      ) S
(break) K
(;) p n
(nonbonded_outerloop.cc) (Page 33/40) (Dec 06, 18 14:53) title
border
/v 1 store
/x0 x v get 2.965278 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
0 T (    ) p
(default) K
(:) p n
0 T (      io::messages.add\(") S
(charge shape not implemented) str
(", ") p
(Lattice Sum) str
(",) p n
0 T (              io::message::critical\);) N
(2255) # (  }) N
0 T (  ) S
(const) K
( ) p
(double) k
( volume = math::volume\(conf.current\(\).box, conf.boundary_type\);) p n
0 T (  ) S
(const) K
( ) p
(double) k
( width = sim.param\(\).nonbonded.ls_charge_shape_width;) p n
0 T (  ) S
(// see MD05.32 Table 6) c n
0 T () S
(  a1 *= -math::Pi * width * width / volume;) p n
(2260) # (  a3 *= -1.0 / width;) N
0 T () N
0 T (  math::SymmetricMatrix a1_self_term_virial\(0.0\);) N
0 T (  math::SymmetricMatrix a1_constant_term_virial\(0.0\);) N
0 T (  ) S
(// calculate the virial contribution of the A1 term) c n
(2265) # () N
0 T () S
(  ) p
(if) K
( \(do_virial\) {) p n
0 T (    ) S
(// A1 virial) c n
0 T () S
(    ) p
(const) K
( ) p
(double) k
( a1_isotropic_self_virial = -0.25 * math::four_pi_eps_i * a1 * s) p n
0 T (t2;) N
0 T (    DEBUG\(10, ") S
(\\ta1 self virial: ) str
(" << a1_isotropic_self_virial\);) p n
(2270) # (    a1_self_term_virial.add_to_diagonal\(a1_isotropic_self_virial\);) N
0 T (    ) S
(const) K
( ) p
(double) k
( a1_isotopic_constant_virial = -0.25 * math::four_pi_eps_i * a1 ) p n
0 T (* \(s2 - st2\);) N
0 T (    DEBUG\(10, ") S
(\\ta1 constant virial: ) str
(" << a1_isotopic_constant_virial\);) p n
0 T (    a1_constant_term_virial.add_to_diagonal\(a1_isotopic_constant_virial\);) N
0 T (  }) N
(2275) # () N
0 T (  math::SymmetricMatrix a2_virial\(0.0\);) N
0 T (  ) S
(// calculate the a2 term) c n
0 T () S
(  ) p
(// do we have to do it numerically?) c n
0 T () S
(  ) p
(if) K
( \(sim.param\(\).nonbonded.ls_calculate_a2 == simulation::ls_a2_numerical ||) p n
(2280) # (          sim.param\(\).nonbonded.ls_calculate_a2 == simulation::ls_a2t_exact_a2_n) N
0 T (umerical ||) N
0 T (          sim.param\(\).nonbonded.ls_calculate_a2 == simulation::ls_a2t_ave_a2_num) N
0 T (erical\) {) N
0 T () N
0 T (    ) S
(// check whether the box is a cube.) c n
0 T () S
(    ) p
(bool) k
( box_is_cube = sim.param\(\).boundary.boundary == math::rectangular &&) p n
(2285) # (            conf.current\(\).box\(0\)\(0\) == conf.current\(\).box\(1\)\(1\) &&) N
0 T (            conf.current\(\).box\(0\)\(0\) == conf.current\(\).box\(2\)\(2\);) N
0 T () N
0 T (    ) S
(if) K
( \(box_is_cube\) {) p n
0 T (      ) S
(// use precalculated values for A2 and the virial. The cubic case) c n
(2290) # () S
(      DEBUG\(10, ") p
(a2: using precalculated values for cube.) str
("\);) p n
0 T (      ) S
(const) K
( ) p
(double) k
( wigner_cube = -2.83729748;) p n
0 T (      a2 = wigner_cube / conf.current\(\).box\(0\)\(0\) - a1 - a3;) N
0 T (      ) S
(if) K
( \(do_virial\) {) p n
0 T (        math::SymmetricMatrix a2_derivative\(0.0\);) N
(2295) # (        a2_derivative.add_to_diagonal\(wigner_cube / \(3.0 * conf.current\(\).box\(0\)) N
0 T (\(0\)\) - a1\);) N
0 T (        a2_virial = \(-0.25 * st2 * math::four_pi_eps_i\) * a2_derivative;) N
0 T (      }) N
0 T (    } ) S
(else) K
( {) p n
0 T (      ) S
(// calculate A2 numerically. This is the rectangular - triclinc case.) c n
(2300) # () S
(      ) p
(const) K
( ) p
(double) k
( & required_precision = sim.param\(\).nonbonded.ls_a2_tolerance;) p n
0 T (      DEBUG\(10, ") S
(\\tA2 tolerance: ) str
(" << required_precision\)) p n
0 T (      math::Matrix l_to_k = configuration::KSpace_Utils::l_to_k_matrix\() N
0 T (              conf.current\(\).box, conf.boundary_type\);) N
0 T () N
(2305) # (      ) S
(// Here, we loop over the surface of triclinic volumes of increasing) c n
0 T () S
(      ) p
(// size in l-space, and add the successive A2 contributions of these) c n
0 T () S
(      ) p
(// surfaces.) c n
0 T () S
(      math::SymmetricMatrix sum_gammahat\(0.0\);) p n
0 T (      ) S
(int) k
( l_max = 0;) p n
(2310) # (      ) S
(double) k
( tolerance;) p n
0 T (      a2 = 0.0;) N
0 T (      ) S
(do) K
( {) p n
0 T (        ++l_max;) N
0 T (        ) S
(double) k
( term = 0.0;) p n
(2315) # () N
0 T (        ) S
(// the planes are located perpendicular to the axis \(coord\)) c n
0 T () S
(        ) p
(for) K
( \() p
(unsigned) k
( ) p
(int) k
( coord = 0; coord < 3; ++coord\) {) p n
0 T (          ) S
(unsigned) k
( ) p
(int) k
( coord_a, coord_b;) p n
0 T (          ) S
(int) k
( boundary_a, boundary_b;) p n
(nonbonded_outerloop.cc) (Page 34/40) (Dec 06, 18 14:53) title
border
grestore
(Printed by Patrick Bleiziffer) rhead
(nonbonded_outerloop.cc) (17/20) (Thursday December 06, 2018) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (35-36) 18
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 2.965278 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(2320) # (          ) p
(switch) K
( \(coord\) {) p n
0 T (            ) S
(case) K
( 0: ) p
(// plane perpendicular to x) c n
0 T () S
(              coord_a = 1;) p n
0 T (              coord_b = 2;) N
0 T (              boundary_a = l_max;) N
(2325) # (              boundary_b = l_max;) N
0 T (              ) S
(break) K
(;) p n
0 T (            ) S
(case) K
( 1: ) p
(// plane perpendicular to y) c n
0 T () S
(              coord_a = 0;) p n
0 T (              coord_b = 2;) N
(2330) # (              ) S
(// exclude ks in the x plane already considered) c n
0 T () S
(              boundary_a = l_max - 1;) p n
0 T (              boundary_b = l_max;) N
0 T (              ) S
(break) K
(;) p n
0 T (            ) S
(case) K
( 2: ) p
(// plane perpendicular to z) c n
(2335) # () S
(              coord_a = 0;) p n
0 T (              coord_b = 1;) N
0 T (              ) S
(// exclude ks in the x and y plane already consideres) c n
0 T () S
(              boundary_a = l_max - 1;) p n
0 T (              boundary_b = l_max - 1;) N
(2340) # (              ) S
(break) K
(;) p n
0 T (          }) N
0 T () N
0 T (          ) S
(// the plane can be located at -l_max or +l_max but we restrict) c n
0 T () S
(          ) p
(// to summation to the planes localted on +l_max and multiply the resu) c n
0 T (lting) N
(2345) # () S
(          ) p
(// term and derivative by a factor of 2.0) c n
0 T () S
(          DEBUG\(12, ") p
(\\tnew plane) str
("\);) p n
0 T () N
0 T (          ) S
(// loop over the plane excluding edges for some axes) c n
0 T () S
(          ) p
(// here we can introduce parallelization by stride) c n
(2350) # () S
(#ifdef) K
( OMP) p n
0 T () S
(#pragma) K
( omp parallel ) p
(for) K n
0 T (#endif) N
0 T () S
(          ) p
(for) K
( \() p
(int) k
( l_a = -boundary_a + rank; l_a <= boundary_a; l_a += size\) {) p n
0 T (            math::GenericVec<) S
(int) k
(> l\(0\);) p n
(2355) # (            l\(coord\) = l_max;) N
0 T (            l\(coord_a\) = l_a;) N
0 T (            ) S
(for) K
( \() p
(int) k
( l_b = -boundary_b; l_b <= boundary_b; ++l_b\) {) p n
0 T (              l\(coord_b\) = l_b;) N
0 T () N
(2360) # (              DEBUG\(13, ") S
(\\t\\tl: ) str
(" << math::v2s\(l\)\);) p n
0 T (              ) S
(const) K
( math::Vec & k = math::product\(l_to_k, l\);) p n
0 T (              ) S
(const) K
( ) p
(double) k
( k2 = math::abs2\(k\);) p n
0 T (              ) S
(const) K
( ) p
(double) k
( abs_k = sqrt\(k2\);) p n
0 T (              ) S
(const) K
( ) p
(double) k
( ak = abs_k * width;) p n
(2365) # () N
0 T (              ) S
(double) k
( gamma_hat, gamma_hat_prime;) p n
0 T (              ) S
(if) K
( \(do_virial\) {) p n
0 T (                interaction::Lattice_Sum::charge_shape_fourier\(shape,) N
0 T (                        ak, gamma_hat, &gamma_hat_prime\);) N
(2370) # (              } ) S
(else) K
( {) p n
0 T (                interaction::Lattice_Sum::charge_shape_fourier\(shape,) N
0 T (                        ak, gamma_hat\);) N
0 T (              }) N
0 T () N
(2375) # () S
(#ifdef) K
( OMP) p n
0 T () S
(#pragma) K
( omp critical) p n
0 T () S
(#endif) K n
0 T () S
(              term += gamma_hat / k2;) p n
0 T (              DEBUG\(13, ") S
(\\t\\t\\tgamma_hat / k2: ) str
(" << gamma_hat / k2\);) p n
(2380) # () N
0 T (              ) S
(if) K
( \(do_virial\) {) p n
0 T (                ) S
(// factor 2.0 is due to symmetry) c n
0 T () S
(                ) p
(const) K
( ) p
(double) k
( isotropic_factor = 2.0 * \(ak * gamma_hat_prime - 2.) p n
0 T (0 * gamma_hat\) / \(k2 * k2\);) N
0 T () S
(#ifdef) K
( OMP) p n
(2385) # () S
(#pragma) K
( omp critical) p n
0 T () S
(#endif) K n
0 T () S
(                sum_gammahat += math::symmetric_tensor_product\(isotropic_factor ) p n
0 T (* k, k\);) N
0 T (              } ) S
(// virial?) c n
0 T () S
(            }) p n
(nonbonded_outerloop.cc) (Page 35/40) (Dec 06, 18 14:53) title
border
/v 1 store
/x0 x v get 2.965278 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(2390) # (          } ) p
(// loop over planes         ) c n
0 T () S
(        } ) p
(// loop over coordinates) c n
0 T () N
0 T () S
(        ) p
(// now calculate A2 and the relative tolerance) c n
0 T () S
(#ifdef) K
( XXMPI) p n
(2395) # (        ) S
(if) K
( \(sim.mpi\) {) p n
0 T (          ) S
(const) K
( ) p
(double) k
( my_term = term;) p n
0 T (          MPI::COMM_WORLD.Allreduce\(&my_term, &term, 1, MPI::DOUBLE, MPI::SUM\);) N
0 T (        }) N
0 T () S
(#endif) K n
(2400) # () N
0 T () S
(        ) p
(// take symmetry into account) c n
0 T () S
(        term *= 2.0;) p n
0 T () N
0 T (        a2 += term;) N
(2405) # () N
0 T (        ) S
(if) K
( \(do_virial && rank == 0\)) p n
0 T (          sum_gammahat.add_to_diagonal\(term\);) N
0 T () N
0 T (        tolerance = fabs\(term / a2\);) N
(2410) # (        DEBUG\(12, ") S
(\\ttolerance: ) str
(" << tolerance\);) p n
0 T (      } ) S
(while) K
( \(tolerance > required_precision\);) p n
0 T () N
0 T () S
(#ifdef) K
( XXMPI) p n
0 T (      ) S
(// for MPI we only have parts of the A2 derivative sum. So we have to add ) c n
0 T (them here) N
(2415) # () S
(      ) p
(if) K
( \(sim.mpi && do_virial\) {) p n
0 T (        math::SymmetricMatrix sum_gammahat_part = sum_gammahat;) N
0 T () N
0 T (        ) S
(if) K
( \(rank\) { ) p
(// slave) c n
0 T () S
(          MPI::COMM_WORLD.Reduce\(&sum_gammahat_part\(0\), ) p
(NULL) K
(, 6, MPI::DOUBLE, MP) p n
0 T (I::SUM, 0\);) N
(2420) # (        } ) S
(else) K
( { ) p
(// master) c n
0 T () S
(          MPI::COMM_WORLD.Reduce\(&sum_gammahat_part\(0\), &sum_gammahat\(0\), 6,) p n
0 T (                  MPI::DOUBLE, MPI::SUM, 0\);) N
0 T (        }) N
0 T (      }) N
(2425) # () S
(#endif) K n
0 T () N
0 T () S
(      a2 *= 4.0 * math::Pi / volume;) p n
0 T (      ) S
(if) K
( \(do_virial\) {) p n
0 T (        ) S
(const) K
( math::SymmetricMatrix a2_derivative = sum_gammahat * \(4.0 * math::) p n
0 T (Pi / volume\);) N
(2430) # (        DEBUG\(10, ") S
(\\tA2 derivative:\\n\\t) str
(" << math::m2s\(a2_derivative\)\);) p n
0 T (        a2_virial = \(-0.25 * st2 * math::four_pi_eps_i\) * a2_derivative;) N
0 T (      }) N
0 T (    } ) S
(// if triclinic) c n
0 T () N
(2435) # () S
(  }) p n
0 T (  DEBUG\(8, ") S
(\\tA2 virial:\\n) str
(" << math::m2s\(a2_virial\)\);) p n
0 T () N
0 T () S
(#ifdef) K
( XXMPI) p n
0 T (  ) S
(// for MPI we only have parts of the A2~ sums. So we have to add them here) c n
(2440) # () S
(  ) p
(// but only if they were calculated.) c n
0 T () S
(  ) p
(if) K
( \(sim.mpi && \() p n
0 T (          sim.param\(\).nonbonded.ls_calculate_a2 == simulation::ls_a2t_exact ||) N
0 T (          sim.param\(\).nonbonded.ls_calculate_a2 == simulation::ls_a2t_exact_a2_n) N
0 T (umerical ||) N
0 T (          sim.param\(\).nonbonded.ls_calculate_a2 == simulation::ls_a2t_ave_a2_num) N
0 T (erical\)\) {) N
(2445) # () N
0 T (    ) S
(const) K
( ) p
(double) k
( a2_part = conf.lattice_sum\(\).a2_tilde;) p n
0 T (    math::SymmetricMatrix a2_deriv_part = conf.lattice_sum\(\).a2_tilde_derivative) N
0 T (;) N
0 T () N
0 T (    ) S
(if) K
( \(rank\) { ) p
(// slave) c n
(2450) # () S
(      MPI::COMM_WORLD.Reduce\(&a2_part, ) p
(NULL) K
(, 1, MPI::DOUBLE, MPI::SUM, 0\);) p n
0 T (      MPI::COMM_WORLD.Reduce\(&a2_deriv_part\(0\), ) S
(NULL) K
(, 6, MPI::DOUBLE, MPI::SUM, ) p n
0 T (0\);) N
0 T (    } ) S
(else) K
( { ) p
(// master) c n
0 T () S
(      MPI::COMM_WORLD.Reduce\(&a2_part, &conf.lattice_sum\(\).a2_tilde, 1,) p n
0 T (              MPI::DOUBLE, MPI::SUM, 0\);) N
(2455) # (      MPI::COMM_WORLD.Reduce\(&a2_deriv_part\(0\), &conf.lattice_sum\(\).a2_tilde_der) N
(nonbonded_outerloop.cc) (Page 36/40) (Dec 06, 18 14:53) title
border
grestore
(Printed by Patrick Bleiziffer) rhead
(nonbonded_outerloop.cc) (18/20) (Thursday December 06, 2018) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (37-38) 19
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 2.965278 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
0 T (ivative\(0\), 6,) p n
0 T (              MPI::DOUBLE, MPI::SUM, 0\);) N
0 T (    }) N
0 T (  }) N
0 T () S
(#endif) K n
(2460) # () S
(  math::SymmetricMatrix a2_tilde_virial\(0.0\);) p n
0 T (  ) S
(if) K
( \(do_virial && \() p n
0 T (          sim.param\(\).nonbonded.ls_calculate_a2 == simulation::ls_a2t_exact ||) N
0 T (          sim.param\(\).nonbonded.ls_calculate_a2 == simulation::ls_a2t_exact_a2_n) N
0 T (umerical ||) N
0 T (          sim.param\(\).nonbonded.ls_calculate_a2 == simulation::ls_a2t_ave_a2_num) N
0 T (erical\)\) {) N
(2465) # (    ) S
(// calculate the virial of the methodology dependent A2 term) c n
0 T () S
(    a2_tilde_virial = \(-0.25 * st2 * math::four_pi_eps_i\) *) p n
0 T (            conf.lattice_sum\(\).a2_tilde_derivative;) N
0 T (    DEBUG\(8, ") S
(A2 tilde virial: ) str
(" << math::m2s\(a2_tilde_virial\)\);) p n
0 T (  }) N
(2470) # () N
0 T (  ) S
(switch) K
( \(sim.param\(\).nonbonded.ls_calculate_a2\) {) p n
0 T (    ) S
(case) K
( simulation::ls_a2_zero:) p n
0 T (      ) S
(// we just set both A2 to zero.) c n
0 T () S
(      a2 = a2_tilde = 0.0;) p n
(2475) # (      a2_virial = a2_tilde_virial = 0.0;) N
0 T (      ) S
(break) K
(;) p n
0 T (    ) S
(case) K
( simulation::ls_a2t_exact:) p n
0 T (      ) S
(// A2t was calculated exactly by Ewald/P3M. A2 is set to A2t) c n
0 T () S
(      a2 = a2_tilde;) p n
(2480) # (      a2_virial = a2_tilde_virial;) N
0 T (    ) S
(case) K
( simulation::ls_a2_numerical:) p n
0 T (      ) S
(// A2 was calculate numerically, A2t is set to A2) c n
0 T () S
(      a2_tilde = a2;) p n
0 T (      a2_tilde_virial = a2_virial;) N
(2485) # (      ) S
(break) K
(;) p n
0 T (    ) S
(case) K
( simulation::ls_a2t_exact_a2_numerical:) p n
0 T (    ) S
(case) K
( simulation::ls_a2t_ave_a2_numerical:) p n
0 T (      ) S
(// we already have A2t and A2 and the virials) c n
0 T () S
(      ) p
(break) K
(;) p n
(2490) # (    ) S
(default) K
(:) p n
0 T (      io::messages.add\(") S
(A2 calculation method not implemented) str
(", ") p
(Lattice Sum) str
(",) p n
0 T (              io::message::critical\);) N
0 T (  } ) S
(// switch ls_calculate_a2) c n
0 T () N
(2495) # () S
(  DEBUG\(8, ") p
(a1 = ) str
(" << a1 << ") p
(, a2 = ) str
(" << a2 << ") p
(, ~a2 = ) str
(" << a2_tilde << ") p
(, a3 = ) str
(" << a3\);) p n
0 T (  ) S
(// now combine everything \(MD05.32 eq 54\)) c n
0 T () S
(  ) p
(if) K
( \(rank == 0\) {) p n
0 T (    storage.energies.ls_self_total = \(a1 + a2 + a3\) * st2 * math::eps0_i / \(8.0 ) N
0 T (* math::Pi\);) N
0 T (    ) S
(if) K
( \(do_virial\) {) p n
(2500) # (      ) S
(// we have to remove the A2 virial from the self term virial) c n
0 T () S
(      ) p
(const) K
( math::SymmetricMatrix self_term_virial = a1_self_term_virial + a2_vi) p n
0 T (rial;) N
0 T () S
(// !!! since multiplication with -0.5 in pressure calc, multiply with -2 here) c n
0 T () S
(     ) p
(// storage.virial_tensor += self_term_virial;) c n
0 T () S
(      storage.virial_tensor +=  \( -2.0 * self_term_virial \);) p n
(2505) # (      DEBUG\(6, ") S
(\\tself term virial:\\n\\t) str
(" << math::m2s\(self_term_virial\)\);) p n
0 T (    } ) S
(// virial) c n
0 T () S
(  } ) p
(else) K
( {) p n
0 T (    storage.energies.ls_self_total = 0.0;) N
0 T (  }) N
(2510) # () N
0 T (  DEBUG\(6, ") S
(ls_self_total = ) str
(" << storage.energies.ls_self_total\);) p n
0 T () N
0 T (  ) S
(// now calculate the E_A term) c n
0 T () S
(  ) p
(if) K
( \(rank == 0\) {) p n
(2515) # (    storage.energies.ls_a_term_total = \(a1 * s2 - \(a1 + a2_tilde\) * st2\) * math:) N
0 T (:eps0_i / \(8.0 * math::Pi\);) N
0 T (    ) S
(if) K
( \(do_virial\) {) p n
0 T (      ) S
(// We have to add the A2~ virial to the constant term virial) c n
0 T () S
(      ) p
(const) K
( math::SymmetricMatrix constant_term_virial = a1_constant_term_virial) p n
0 T ( - a2_tilde_virial;) N
0 T () S
(// !!! since multiplication with -0.5 in pressure calc, multiply with -2 here) c n
(2520) # () S
(     ) p
(// storage.virial_tensor += constant_term_virial;) c n
0 T () S
(      storage.virial_tensor += \( -2.0 *  constant_term_virial \);) p n
(nonbonded_outerloop.cc) (Page 37/40) (Dec 06, 18 14:53) title
border
/v 1 store
/x0 x v get 2.965278 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
0 T (      DEBUG\(6, ") p
(\\tconstant term virial:\\n\\t) str
(" << math::m2s\(constant_term_virial\)\);) p n
0 T (    } ) S
(// virial) c n
0 T () S
(  } ) p
(else) K
( {) p n
(2525) # (    storage.energies.ls_a_term_total = 0.0;) N
0 T (  }) N
0 T (  DEBUG\(6, ") S
(ls_a_term_total = ) str
(" << storage.energies.ls_a_term_total\);) p n
0 T () N
0 T (  ) S
(if) K
( \(sim.param\(\).pcouple.scale == math::pcouple_off && !sim.steps\(\)\){ ) p
(// NVT an) c n
0 T (d first step) N
(2530) # () S
(    conf.current\(\).energies.ls_self_total_nvt = storage.energies.ls_self_total;) p n
0 T (    conf.old\(\).energies.ls_self_total_nvt = storage.energies.ls_self_total;) N
0 T (    conf.current\(\).energies.ls_a_term_total_nvt = storage.energies.ls_a_term_tot) N
0 T (al;) N
0 T (    conf.old\(\).energies.ls_a_term_total_nvt = storage.energies.ls_a_term_total;) N
0 T (  }) N
(2535) # (}) N
0 T () N
0 T () S
(void) k
( interaction::Nonbonded_Outerloop) p n
0 T (::ls_surface_outerloop\(topology::Topology & topo,) N
0 T (        configuration::Configuration & conf,) N
(2540) # (        simulation::Simulation & sim,) N
0 T (        Storage & storage, ) S
(int) k
( rank, ) p
(int) k
( size\) {) p n
0 T (  SPLIT_INNERLOOP\(_ls_surface_outerloop, topo, conf, sim,) N
0 T (          storage, rank, size\);) N
0 T (}) N
(2545) # () N
0 T () S
(template) K
(<) p
(typename) k
( t_interaction_spec>) p n
0 T () S
(void) k
( interaction::Nonbonded_Outerloop) p n
0 T (::_ls_surface_outerloop\(topology::Topology & topo,) N
0 T (        configuration::Configuration & conf,) N
(2550) # (        simulation::Simulation & sim,) N
0 T (        Storage & storage, ) S
(int) k
( rank, ) p
(int) k
( size\) {) p n
0 T (  DEBUG\(8, ") S
(\\telectrostatic surface terms) str
("\);) p n
0 T () N
0 T (  ) S
(// under tinfoil boundary conditions we don't have) c n
(2555) # () S
(  ) p
(// to calculate anything as the terms are zero.) c n
0 T () S
(  ) p
(if) K
( \(sim.param\(\).nonbonded.ls_epsilon == 0.0\) {) p n
0 T (    DEBUG\(10, ") S
(\\ttinfoil.) str
("\);) p n
0 T (    storage.energies.ls_surface_total = 0.0;) N
0 T (    ) S
(return) K
(;) p n
(2560) # (  }) N
0 T () N
0 T (  math::Vec box_dipole_moment\(0.0\);) N
0 T (  math::Vec box_centre = conf.current\(\).box\(0\) / 2.0 +) N
0 T (          conf.current\(\).box\(1\) / 2.0 +) N
(2565) # (          conf.current\(\).box\(2\) / 2.0;) N
0 T () N
0 T (  math::Periodicity<t_interaction_spec::boundary_type> periodicity\(conf.current\() N
0 T (\).box\);) N
0 T () N
0 T (  ) S
(const) K
( ) p
(unsigned) k
( ) p
(int) k
( num_atoms = topo.num_atoms\(\);) p n
(2570) # (  ) S
(for) K
( \() p
(unsigned) k
( ) p
(int) k
( i = 0; i < num_atoms; i++\) {) p n
0 T (    math::Vec r = conf.current\(\).pos\(i\);) N
0 T (    box_dipole_moment += topo.charge\(i\) * \(r - box_centre\);) N
0 T (  }) N
0 T () N
(2575) # (  ) S
(// now we have the box dipole moment and can calculate the energy and force) c n
0 T () S
(  ) p
(const) K
( ) p
(double) k
( prefactor = math::eps0_i /) p n
0 T (          \(\(sim.param\(\).nonbonded.ls_epsilon * 2.0 + 1.0\) *) N
0 T (          math::volume\(conf.current\(\).box, conf.boundary_type\)\);) N
0 T () N
(2580) # (  ) S
(const) K
( ) p
(double) k
( abs2_box_dipole_moment = math::abs2\(box_dipole_moment\);) p n
0 T (  storage.energies.ls_surface_total = 0.5 * abs2_box_dipole_moment * prefactor;) N
0 T (  DEBUG\(6, ") S
(\\tsurface energy: ) str
(" << storage.energies.ls_surface_total\);) p n
0 T () N
0 T (  ) S
(for) K
( \() p
(unsigned) k
( ) p
(int) k
( i = 0; i < num_atoms; i++\) {) p n
(2585) # (    storage.force\(i\) += -prefactor * topo.charge\(i\) * box_dipole_moment;) N
0 T (  }) N
0 T () N
0 T (  ) S
(// do the virial) c n
0 T () S
(  ) p
(if) K
( \(sim.param\(\).pcouple.virial != math::no_virial\) {) p n
(2590) # (    math::Matrix virial\(0.0\);) N
0 T (    ) S
(const) K
( ) p
(double) k
( isotropic_term = -0.25 * prefactor * abs2_box_dipole_moment;) p n
(nonbonded_outerloop.cc) (Page 38/40) (Dec 06, 18 14:53) title
border
grestore
(Printed by Patrick Bleiziffer) rhead
(nonbonded_outerloop.cc) (19/20) (Thursday December 06, 2018) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (39-40) 20
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 2.965278 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
0 T (    ) p
(for) K
( \() p
(unsigned) k
( ) p
(int) k
( i = 0; i < 3; ++i\) {) p n
0 T (      virial\(i, i\) = isotropic_term) N
0 T (              + 0.5 * prefactor * box_dipole_moment\(i\) * box_dipole_moment\(i\);) N
(2595) # (    }) N
0 T (    storage.virial_tensor += virial;) N
0 T (    DEBUG\(6, ") S
(surface term virial: ) str
(" << math::m2s\(virial\)\);) p n
0 T (  }) N
0 T (}) N
(2600) # () N
0 T () S
(/**) c n
0 T ( * calculate the interaction for a given atom pair.) N
0 T ( * SLOW! as it has to create the periodicity...) N
0 T ( */) N
(2605) # () S
(int) k
( interaction::Nonbonded_Outerloop::calculate_interaction) p n
0 T (\() N
0 T (        topology::Topology & topo,) N
0 T (        configuration::Configuration & conf,) N
0 T (        simulation::Simulation & sim,) N
(2610) # (        ) S
(unsigned) k
( ) p
(int) k
( atom_i, ) p
(unsigned) k
( ) p
(int) k
( atom_j,) p n
0 T (        math::Vec & force,) N
0 T (        ) S
(double) k
( &e_lj, ) p
(double) k
( &e_crf) p n
0 T (        \) {) N
0 T (  SPLIT_INNERLOOP\(_calculate_interaction, topo, conf, sim, atom_i, atom_j, force) N
0 T (, e_lj, e_crf\);) N
(2615) # (  ) S
(return) K
( 0;) p n
0 T (}) N
0 T () N
0 T () S
(template) K
(<) p
(typename) k
( t_interaction_spec>) p n
0 T () S
(int) k
( interaction::Nonbonded_Outerloop) p n
(2620) # (::_calculate_interaction\(topology::Topology & topo,) N
0 T (        configuration::Configuration & conf,) N
0 T (        simulation::Simulation & sim,) N
0 T (        ) S
(unsigned) k
( ) p
(int) k
( atom_i, ) p
(unsigned) k
( ) p
(int) k
( atom_j,) p n
0 T (        math::Vec & force,) N
(2625) # (        ) S
(double) k
( & e_lj, ) p
(double) k
( & e_crf\) {) p n
0 T (  math::Vec r;) N
0 T (  math::Periodicity<t_interaction_spec::boundary_type> periodicity\(conf.current\() N
0 T (\).box\);) N
0 T () N
0 T (  Nonbonded_Term term;) N
(2630) # (  term.init\(sim\);) N
0 T () N
0 T (  ) S
(const) K
( lj_parameter_struct &lj =) p n
0 T (          m_param.lj_parameter\(topo.iac\(atom_i\),) N
0 T (          topo.iac\(atom_j\)\);) N
(2635) # () N
0 T (  periodicity.nearest_image\(conf.current\(\).pos\(atom_i\), conf.current\(\).pos\(atom_) N
0 T (j\), r\);) N
0 T (  DEBUG\(10, ") S
(\\tni i ) str
(" << conf.current\(\).pos\(atom_i\)\(0\) << ") p
( / ) str
(") p n
0 T (          << conf.current\(\).pos\(atom_i\)\(1\) << ") S
( / ) str
(") p n
0 T (          << conf.current\(\).pos\(atom_i\)\(2\)\);) N
(2640) # (  DEBUG\(10, ") S
(\\tni j ) str
(" << conf.current\(\).pos\(atom_j\)\(0\) << ") p
( / ) str
(") p n
0 T (          << conf.current\(\).pos\(atom_j\)\(1\) << ") S
( / ) str
(") p n
0 T (          << conf.current\(\).pos\(atom_j\)\(2\)\);) N
0 T (  DEBUG\(10, ") S
(\\tni r ) str
(" << r\(0\) << ") p
( / ) str
(" << r\(1\) << ") p
( / ) str
(" << r\(2\)\);) p n
0 T (  ) S
(double) k
( f;) p n
(2645) # (  term.lj_crf_interaction\(r, lj.c6, lj.c12,) N
0 T (          topo.charge\(\)\(atom_i\) * topo.charge\(\)\(atom_j\),) N
0 T (          f, e_lj, e_crf\);) N
0 T (  force = f * r;) N
0 T () N
(2650) # (  ) S
(return) K
( 0;) p n
0 T (}) N
0 T () N
0 T () S
(/**) c n
0 T ( * calculate the hessian for a given atom.) N
(2655) # ( * this will be VERY SLOW !) N
0 T ( */) N
0 T () S
(int) k
( interaction::Nonbonded_Outerloop) p n
0 T (::calculate_hessian\(topology::Topology & topo,) N
0 T (        configuration::Configuration & conf,) N
(2660) # (        simulation::Simulation & sim,) N
0 T (        ) S
(unsigned) k
( ) p
(int) k
( atom_i, ) p
(unsigned) k
( ) p
(int) k
( atom_j,) p n
(nonbonded_outerloop.cc) (Page 39/40) (Dec 06, 18 14:53) title
border
/v 1 store
/x0 x v get 2.965278 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
0 T (        math::Matrix & hessian,) p n
0 T (        PairlistContainer ) S
(const) K
( & pairlist\) {) p n
0 T () N
(2665) # (  SPLIT_INNERLOOP\(_calculate_hessian, topo, conf, sim, atom_i, atom_j, hessian, ) N
0 T (pairlist\);) N
0 T (  ) S
(return) K
( 0;) p n
0 T (}) N
0 T () N
0 T () S
(template) K
(<) p
(typename) k
( t_interaction_spec>) p n
(2670) # () S
(int) k
( interaction::Nonbonded_Outerloop) p n
0 T (::_calculate_hessian\(topology::Topology & topo,) N
0 T (        configuration::Configuration & conf,) N
0 T (        simulation::Simulation & sim,) N
0 T (        ) S
(unsigned) k
( ) p
(int) k
( atom_i, ) p
(unsigned) k
( ) p
(int) k
( atom_j,) p n
(2675) # (        math::Matrix & hessian,) N
0 T (        PairlistContainer ) S
(const) K
( & pairlist\) {) p n
0 T () N
0 T (  hessian = 0.0;) N
0 T () N
(2680) # (  ) S
(// loop over the pairlist) c n
0 T () N
0 T () S
(  ) p
(//*************************) c n
0 T () S
(  ) p
(// standard implementation) c n
0 T () S
(  ) p
(//*************************) c n
(2685) # () N
0 T () S
(  ) p
(// check whether the pair is in one of the shortrange pairlists) c n
0 T () S
(  ) p
(bool) k
( calculate_pair =) p n
0 T (          std::find\(pairlist.solute_short[atom_i].begin\(\),) N
0 T (          pairlist.solute_short[atom_i].end\(\),) N
(2690) # (          atom_j\) != pairlist.solute_short[atom_i].end\(\) || ) S
(// i-j in solute) c n
0 T () S
(          std::find\(pairlist.solute_short[atom_j].begin\(\),) p n
0 T (          pairlist.solute_short[atom_j].end\(\),) N
0 T (          atom_i\) != pairlist.solute_short[atom_j].end\(\) || ) S
(// j-i in solute) c n
0 T () S
(          std::find\(pairlist.solvent_short[atom_i].begin\(\),) p n
(2695) # (          pairlist.solvent_short[atom_i].end\(\),) N
0 T (          atom_j\) != pairlist.solvent_short[atom_i].end\(\) || ) S
(// i-j in solvent) c n
0 T () S
(          std::find\(pairlist.solvent_short[atom_j].begin\(\),) p n
0 T (          pairlist.solvent_short[atom_j].end\(\),) N
0 T (          atom_i\) != pairlist.solvent_short[atom_j].end\(\); ) S
(// j-i in solvent) c n
(2700) # () N
0 T () S
(  ) p
(if) K
( \(calculate_pair\) {) p n
0 T (    math::Vec r;) N
0 T (    math::Matrix h;) N
0 T (    math::Periodicity<t_interaction_spec::boundary_type> periodicity\(conf.curren) N
0 T (t\(\).box\);) N
(2705) # () N
0 T (    Nonbonded_Term term;) N
0 T (    term.init\(sim\);) N
0 T () N
0 T (    DEBUG\(8, ") S
(\\thessian pair in pairlist: ) str
(" << atom_i << ") p
( - ) str
(" << atom_j\);) p n
(2710) # () N
0 T (    periodicity.nearest_image\(conf.current\(\).pos\(atom_i\),) N
0 T (            conf.current\(\).pos\(atom_j\),) N
0 T (            r\);) N
0 T (    ) S
(const) K
( lj_parameter_struct &lj =) p n
(2715) # (            m_param.lj_parameter\(topo.iac\(atom_i\),) N
0 T (            topo.iac\(atom_j\)\);) N
0 T () N
0 T (    term.lj_crf_hessian\(r,) N
0 T (            lj.c6, lj.c12,) N
(2720) # (            topo.charge\(\)\(atom_i\) * topo.charge\(\)\(atom_j\),) N
0 T (            h\);) N
0 T () N
0 T (    ) S
(for) K
( \() p
(unsigned) k
( ) p
(int) k
( d1 = 0; d1 < 3; ++d1\)) p n
0 T (      ) S
(for) K
( \() p
(unsigned) k
( ) p
(int) k
( d2 = 0; d2 < 3; ++d2\)) p n
(2725) # (        hessian\(d1, d2\) += h\(d1, d2\);) N
0 T (  }) N
0 T () N
0 T (  ) S
(return) K
( 0;) p n
0 T (}) N
(nonbonded_outerloop.cc) (Page 40/40) (Dec 06, 18 14:53) title
border
grestore
(Printed by Patrick Bleiziffer) rhead
(nonbonded_outerloop.cc) (20/20) (Thursday December 06, 2018) footer
end % of iso1dict
pagesave restore
showpage

%%Trailer
end
%%EOF
